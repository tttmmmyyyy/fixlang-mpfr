// Provides arbitrary-precision floating-point type `MPFR` and related functions.
// 
// This is a wrapper for the GNU MPFR (Multiple Precision Floating-Point Reliable) Library.
module MPFR;

import Std::{
    undefined, unsafe_is_unique, Add, Array, Bool, Box, Div, Eq, F64, I64, IO, LessThan, LessThanOrEq, 
    Mul, Neg, Option, Ptr, String, Sub, ToString, U64, U8, Zero, Array::{fill, pop_back, to_iter}, 
    Box::{@value, make}, Debug::debug_println, 
    FFI::{mutate_boxed, CInt, Destructor, Destructor::{borrow, make, mutate_unique}}, IO::unsafe_perform, 
    Iterator::{check_all, check_any, fold}, LessThan::max, Monad::pure, Option::{none, some}, 
    String::{
        @size, borrow_c_str, get_bytes, get_sub, starts_with, strip_last_bytes, to_iter_bytes, 
        unsafe_from_c_str_ptr_io
    }, 
    ToCInt::c_int, ToCLong::c_long, ToCUnsignedLong::c_unsigned_long, ToI64::i64, ToString::to_string, 
    ToU64::u64, Tuple2::@0
};

// Precision type for MPFR numbers (in bits).
type Precision = I64;

// A pointer to struct `__mpfr_struct`.
type MPFRHandle = Ptr;

// Size of `__mpfr_struct`.
// On 64-bit systems, this is typically 32 bytes.
c_SIZE_OF_MPFR : CInt;
c_SIZE_OF_MPFR = 32.c_int;

// Rounding mode for MPFR operations.
type RoundMode = unbox union {
    rndn : (),  // Round to Nearest (ties to even)
    rndz : (),  // Round toward Zero
    rndu : (),  // Round toward positive infinity
    rndd : (),  // Round toward negative infinity
    rnda : ()   // Round Away from zero
};

namespace RoundMode {
    // Convert RoundMode to C integer constant.
    to_c_rnd : RoundMode -> CInt;
    to_c_rnd = |rnd| (
        match rnd {
            rndn() => 0.c_int,
            rndz() => 1.c_int,
            rndu() => 2.c_int,
            rndd() => 3.c_int,
            rnda() => 4.c_int,
        }
    );
}

namespace MPFRHandle {
    // Construct MPFRHandle by MPFR's initialization function with precision.
    _construct_by : Precision -> (MPFRHandle -> IO a) -> IO (MPFRHandle, a);
    _construct_by = |prec, ctor| (
        let handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SIZE_OF_MPFR];
        FFI_CALL_IO[() mpfr_init2(Ptr, CLong), handle, prec.c_long];;
        let res = *ctor(handle);
        pure $ (handle, res)
    );

    // Copy constructor: allocates new handle and copies value.
    _copy_constructor : MPFRHandle -> IO MPFRHandle;
    _copy_constructor = |handle| (
        // Get precision of source
        let prec = FFI_CALL[CLong mpfr_get_prec(Ptr), handle];
        let new_handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SIZE_OF_MPFR];
        FFI_CALL_IO[() mpfr_init2(Ptr, CLong), new_handle, prec];;
        FFI_CALL_IO[CInt mpfr_set(Ptr, Ptr, CInt), new_handle, handle, RoundMode::rndn().to_c_rnd];;
        pure $ new_handle
    );

    // Destructor: calls mpfr_clear and frees memory.
    _destructor : MPFRHandle -> IO MPFRHandle;
    _destructor = |handle| (
        FFI_CALL_IO[() mpfr_clear(Ptr), handle];;
        FFI_CALL_IO[() free(Ptr), handle];;
        pure $ nullptr
    );
}

// Arbitrary-precision floating-point number type.
type MPFR = unbox struct { _0 : Destructor MPFRHandle };

namespace MPFR {
    // Initialize a new MPFR using specified initialization action.
    _init_by : Precision -> (MPFRHandle -> IO a) -> (MPFR, a);
    _init_by = |prec, ctor| do {
        let (handle, res) = *MPFRHandle::_construct_by(prec, ctor);
        let dtor = *Destructor::make(handle, MPFRHandle::_destructor);
        pure $ (MPFR { _0 : dtor }, res)
    }.unsafe_perform;

    // Performs an action with a borrowed pointer to the internal data.
    _borrow : (MPFRHandle -> a) -> MPFR -> a;
    _borrow = |act, num| num.@_0.borrow(|handle| act(handle));

    // Acts on the internal data of the MPFR, which may mutate the MPFR value.
    _mutate : (MPFRHandle -> IO a) -> MPFR -> (MPFR, a);
    _mutate = |act, num| (
        let dtor = num.@_0;
        let (dtor, res) = dtor.mutate_unique(MPFRHandle::_copy_constructor, act);
        (MPFR { _0 : dtor }, res)
    );

    // Get the precision of an MPFR number.
    // 
    // # Parameters
    // - `x`: The number to get precision of.
    get_prec : MPFR -> Precision;
    get_prec = |num| (
        num._borrow(|ptr| FFI_CALL[CLong mpfr_get_prec(Ptr), ptr].i64)
    );

    // Apply a unary operation of MPFR (taking (out, in, rnd) as arguments) to an MPFR value.
    _unary_op : RoundMode -> ((MPFRHandle, MPFRHandle, CInt) -> IO CInt) -> MPFR -> (MPFR, CInt);
    _unary_op = |rnd, act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        let rnd_c = rnd.to_c_rnd;
        if is_unique {
            num._mutate(|num_ptr| act((num_ptr, num_ptr, rnd_c)))
        };
        let prec = num.get_prec;
        num._borrow(|num_ptr|
            MPFR::_init_by(prec, |out_ptr| act((out_ptr, num_ptr, rnd_c)))
        )
    );

    // Apply a binary operation of MPFR (taking (out, lhs, rhs, rnd) as arguments) to two MPFR values.
    _binary_op : RoundMode -> Precision -> ((MPFRHandle, MPFRHandle, MPFRHandle, CInt) -> IO CInt) -> MPFR -> MPFR -> (MPFR, CInt);
    _binary_op = |rnd, prec, act, lhs, rhs| (
        let (is_unique, lhs) = lhs.unsafe_is_unique;
        let rnd_c = rnd.to_c_rnd;
        if is_unique && lhs.get_prec == prec {
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| act((lhs_ptr, lhs_ptr, rhs_ptr, rnd_c)))
            )
        };
        let (is_unique, rhs) = rhs.unsafe_is_unique;
        if is_unique && rhs.get_prec == prec {
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| act((rhs_ptr, lhs_ptr, rhs_ptr, rnd_c)))
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPFR::_init_by(prec, |out_ptr| act((out_ptr, lhs_ptr, rhs_ptr, rnd_c)))
            )
        )
    );

    // Create an MPFR value from an I64 with specified precision.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    // - `val`: The I64 value to convert.
    mpfr_i : Precision -> I64 -> MPFR;
    mpfr_i = |prec, val| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_set_si(Ptr, CLong, CInt), ptr, val.c_long, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Create an MPFR value from a U64 with specified precision.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    // - `val`: The U64 value to convert.
    mpfr_ui : Precision -> U64 -> MPFR;
    mpfr_ui = |prec, val| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_set_ui(Ptr, CUnsignedLong, CInt), ptr, val.c_unsigned_long, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Create an MPFR value from an F64 with specified precision.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    // - `val`: The F64 value to convert.
    mpfr : Precision -> F64 -> MPFR;
    mpfr = |prec, val| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_set_d(Ptr, CDouble, CInt), ptr, val, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Create an MPFR value from a string with specified precision and base.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    // - `str`: The string representation of the number.
    // - `base`: The base of the string representation (2 to 62, or 0 for auto-detection).
    mpfr_str : Precision -> String -> I64 -> Option MPFR;
    mpfr_str = |prec, str, base| (
        str.borrow_c_str(|str_c_str| (
            let (num, res) = MPFR::_init_by(prec, |ptr| 
                FFI_CALL_IO[CInt mpfr_set_str(Ptr, Ptr, CInt, CInt), ptr, str_c_str, base.c_int, RoundMode::rndn().to_c_rnd]
            );
            if res == (-1).c_int { Option::none() };
            Option::some $ num
        ))
    );

    // Create an MPFR value representing zero.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    zero : Precision -> MPFR;
    zero = |prec| mpfr_i(prec, 0);

    // Create an MPFR value representing NaN (Not a Number).
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    nan : Precision -> MPFR;
    nan = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| FFI_CALL_IO[() mpfr_set_nan(Ptr), ptr]);
        num
    );

    // Create an MPFR value representing positive infinity.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    inf : Precision -> MPFR;
    inf = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[() mpfr_set_inf(Ptr, CInt), ptr, 1.c_int]
        );
        num
    );

    // Create an MPFR value representing negative infinity.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    neg_inf : Precision -> MPFR;
    neg_inf = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[() mpfr_set_inf(Ptr, CInt), ptr, (-1).c_int]
        );
        num
    );

    // Convert an MPFR value to I64.
    // 
    // Rounds toward zero. Returns none if the value doesn't fit in I64.
    // 
    // # Parameters
    // - `x`: The MPFR number to convert.
    get_si : MPFR -> Option I64;
    get_si = |num| (
        num._borrow(|ptr| (
            // Check if value fits in I64 range
            let fits = FFI_CALL[CInt mpfr_fits_slong_p(Ptr, CInt), ptr, RoundMode::rndz().to_c_rnd];
            if fits == 0.c_int { Option::none() };
            let val = FFI_CALL[CLong mpfr_get_si(Ptr, CInt), ptr, RoundMode::rndz().to_c_rnd];
            Option::some $ val.i64
        ))
    );

    // Convert an MPFR value to U64.
    // 
    // Rounds toward zero. Returns none if the value doesn't fit in U64.
    // 
    // # Parameters
    // - `x`: The MPFR number to convert.
    get_ui : MPFR -> Option U64;
    get_ui = |num| (
        num._borrow(|ptr| (
            let fits = FFI_CALL[CInt mpfr_fits_ulong_p(Ptr, CInt), ptr, RoundMode::rndz().to_c_rnd];
            if fits == 0.c_int { Option::none() };
            let val = FFI_CALL[CUnsignedLong mpfr_get_ui(Ptr, CInt), ptr, RoundMode::rndz().to_c_rnd];
            Option::some $ val
        ))
    );

    // Convert an MPFR value to F64.
    // 
    // May lose precision if the MPFR value has more precision than F64.
    // 
    // # Parameters
    // - `x`: The MPFR number to convert.
    get_f64 : MPFR -> F64;
    get_f64 = |num| (
        num._borrow(|ptr| 
            FFI_CALL[CDouble mpfr_get_d(Ptr, CInt), ptr, RoundMode::rndn().to_c_rnd]
        )
    );

    // Get the number of digits required to represent an MPFR value in a given base.
    // 
    // This function returns the minimal integer m such that any number of p bits,
    // when output in base b with m digits, can be recovered exactly when read back in base b.
    // 
    // # Parameters
    // - `base`: The base (must be in the range [2, 62]).
    // - `prec`: The precision in bits.
    get_str_ndigits : I64 -> Precision -> I64;
    get_str_ndigits = |base, prec| (
        if !(2 <= base && base <= 62) {
            undefined("[MPFR::get_str_ndigits] base must be in the range [2, 62]")
        };
        FFI_CALL[CUnsignedLong mpfr_get_str_ndigits(CInt, CLong), base.c_int, prec.c_long].i64
    );

    // Convert an MPFR value to a string in a given base with specified number of digits.
    // 
    // Returns a tuple of (mantissa_string, exponent) where the mantissa is a fraction
    // with an implicit radix point immediately to the left of the first digit.
    // For example, the number -3.1416 would be returned as ("-31416", 1).
    // 
    // If the number is NaN, returns ("@NaN@", 0).
    // If the number is +Inf, returns ("@Inf@", 0).
    // If the number is -Inf, returns ("-@Inf@", 0).
    // 
    // # Parameters
    // - `base`: The base of the string representation (must be in the range [2, 62] or [-36, -2]).
    // - `n_digits`: Number of significant digits (0 means use get_str_ndigits with the number's precision).
    // - `rnd`: The rounding mode to use.
    // - `num`: The MPFR number to convert.
    get_str : I64 -> I64 -> RoundMode -> MPFR -> (String, I64);
    get_str = |base, n_digits, rnd, num| (
        if !(2 <= base && base <= 62 || -36 <= base && base <= -2) {
            undefined("[MPFR::get_str] base must be in the range [2, 62] or [-36, -2]")
        };
        let base_c = base.c_int;
        let n_digits_c = n_digits.c_unsigned_long;
        let rnd_c = rnd.to_c_rnd;
        num._borrow(|num_ptr| (
            // Use Box to get a mutable pointer for the exponent
            let exp_box = Box::make(0.c_long);
            let (exp_box, str_ptr) = exp_box.mutate_boxed(|exp_ptr|
                FFI_CALL_IO[Ptr mpfr_get_str(Ptr, Ptr, CInt, CUnsignedLong, Ptr, CInt), 
                    nullptr, exp_ptr, base_c, n_digits_c, num_ptr, rnd_c]
            );
            do {
                let str = *String::unsafe_from_c_str_ptr_io(str_ptr);
                let exp = exp_box.@value.i64;
                FFI_CALL_IO[() mpfr_free_str(Ptr), str_ptr];;
                pure $ (str, exp)
            }.unsafe_perform
        ))
    );

    // Convert an MPFR value to exponential form string.
    // 
    // The output format is "d.dddd...e±exp" (e.g., "3.14159e+0", "-1.23456e-10").
    // The number of significant digits is determined by the number's precision.
    // 
    // # Parameters
    // - `num`: The MPFR number to convert.
    to_string_exp : MPFR -> String;
    to_string_exp = |num| (
        let prec = num.get_prec;
        let n_digits = get_str_ndigits(10, prec);
        let (mantissa, exp) = num.get_str(10, n_digits, RoundMode::rndn());
        
        // Handle special values (check if contains '@')
        if mantissa.to_iter_bytes.check_any(|c| c == '@') {
            mantissa
        } else {
            // Handle sign
            let (sign, mantissa) = if mantissa.starts_with("-") {
                ("-", get_sub(1, @size(mantissa), mantissa))
            } else {
                ("", mantissa)
            };
            
            // Handle zero
            let is_zero = mantissa == "" || mantissa.to_iter_bytes.check_all(|c| c == '0');
            if is_zero {
                sign + "0.0e+0"
            } else {
                // Remove trailing zeros from mantissa
                let mantissa = mantissa.strip_last_bytes(|c| c == '0');
                let len = @size(mantissa);
                
                if len == 0 {
                    sign + "0.0e+0"
                } else {
                    // Format as d.dddd...e±exp
                    let first_char = get_sub(0, 1, mantissa);
                    let rest = if len > 1 { get_sub(1, len, mantissa) } else { "0" };
                    let significand = first_char + "." + rest;
                    let exp_val = exp - 1;
                    let exp_str = if exp_val >= 0 { "e+" + exp_val.to_string } else { "e" + exp_val.to_string };
                    sign + significand + exp_str
                }
            }
        }
    );

    // Convert an MPFR value to exponential form string with specified precision.
    // 
    // The output format is "d.{prec digits}e±exp" where the number of digits after
    // the decimal point is exactly `prec`.
    // 
    // # Parameters
    // - `prec`: The number of digits after the decimal point.
    // - `num`: The MPFR number to convert.
    to_string_exp_precision : U8 -> MPFR -> String;
    to_string_exp_precision = |prec, num| (
        // Request prec+1 significant digits (1 for integer part, prec for fractional part)
        let n_digits = prec.i64 + 1;
        let (mantissa, exp) = num.get_str(10, n_digits, RoundMode::rndn());
        
        // Handle special values (check if contains '@')
        if mantissa.to_iter_bytes.check_any(|c| c == '@') {
            mantissa
        } else {
            // Handle sign
            let (sign, mantissa) = if mantissa.starts_with("-") {
                ("-", get_sub(1, @size(mantissa), mantissa))
            } else {
                ("", mantissa)
            };
            
            // Handle zero
            let is_zero = mantissa == "" || mantissa.to_iter_bytes.check_all(|c| c == '0');
            if is_zero {
                let zeros = Array::fill(prec.i64, "0").to_iter.fold("", |s, acc| acc + s);
                sign + "0." + zeros + "e+0"
            } else {
                let len = @size(mantissa);
                
                // Pad or truncate mantissa to prec+1 digits
                let mantissa = if len < n_digits {
                    // Pad with zeros
                    let pad_count = n_digits - len;
                    let zeros = Array::fill(pad_count, "0").to_iter.fold("", |s, acc| acc + s);
                    mantissa + zeros
                } else if len > n_digits {
                    // Truncate
                    get_sub(0, n_digits, mantissa)
                } else {
                    mantissa
                };
                
                // Format as d.{prec digits}e±exp
                let first_char = get_sub(0, 1, mantissa);
                let rest = if n_digits > 1 { get_sub(1, n_digits, mantissa) } else { "" };
                let significand = first_char + "." + rest;
                let exp_val = exp - 1;
                let exp_str = if exp_val >= 0 { "e+" + exp_val.to_string } else { "e" + exp_val.to_string };
                sign + significand + exp_str
            }
        }
    );

    // Convert an MPFR value to string with specified precision (digits after decimal point).
    // 
    // The output format is standard decimal notation with exactly `prec` digits after
    // the decimal point (e.g., "3.14", "-123.456").
    // 
    // # Parameters
    // - `prec`: The number of digits after the decimal point.
    // - `num`: The MPFR number to convert.
    to_string_precision : U8 -> MPFR -> String;
    to_string_precision = |prec, num| (
        let (mantissa, exp) = num.get_str(10, 0, RoundMode::rndn());
        
        // Handle special values (check if contains '@')
        if mantissa.to_iter_bytes.check_any(|c| c == '@') {
            mantissa
        } else {
            // Handle sign
            let (sign, mantissa) = if mantissa.starts_with("-") {
                ("-", get_sub(1, @size(mantissa), mantissa))
            } else {
                ("", mantissa)
            };
            
            // Handle zero
            let is_zero = mantissa == "" || mantissa.to_iter_bytes.check_all(|c| c == '0');
            if is_zero {
                let zeros = Array::fill(prec.i64, "0").to_iter.fold("", |s, acc| acc + s);
                sign + "0." + zeros
            } else {
                let mantissa_len = @size(mantissa);
                
                // Determine where the decimal point should be
                if exp > 0 {
                    // Positive exponent: integer part exists
                    if exp >= mantissa_len {
                        // Number is an integer or larger
                        // Pad with zeros if needed
                        let int_zeros = Array::fill((exp - mantissa_len).i64, "0").to_iter.fold("", |s, acc| acc + s);
                        let frac_zeros = Array::fill(prec.i64, "0").to_iter.fold("", |s, acc| acc + s);
                        sign + mantissa + int_zeros + "." + frac_zeros
                    } else {
                        // Decimal point is within mantissa
                        let int_part = get_sub(0, exp, mantissa);
                        let frac_part = get_sub(exp, mantissa_len, mantissa);
                        let frac_len = @size(frac_part);
                        let frac_part_adjusted = if frac_len < prec.i64 {
                            // Pad fractional part
                            let pad_count = prec.i64 - frac_len;
                            let zeros = Array::fill(pad_count, "0").to_iter.fold("", |s, acc| acc + s);
                            frac_part + zeros
                        } else if frac_len > prec.i64 {
                            // Truncate fractional part
                            get_sub(0, prec.i64, frac_part)
                        } else {
                            frac_part
                        };
                        sign + int_part + "." + frac_part_adjusted
                    }
                } else {
                    // Non-positive exponent: starts with 0.
                    let leading_zeros_count = (-exp).i64;
                    let total_frac_digits = leading_zeros_count + mantissa_len;
                    
                    if total_frac_digits <= prec.i64 {
                        // Pad to reach prec digits
                        let leading_zeros = Array::fill(leading_zeros_count, "0").to_iter.fold("", |s, acc| acc + s);
                        let trailing_zeros_count = prec.i64 - total_frac_digits;
                        let trailing_zeros = Array::fill(trailing_zeros_count, "0").to_iter.fold("", |s, acc| acc + s);
                        sign + "0." + leading_zeros + mantissa + trailing_zeros
                    } else {
                        // Truncate mantissa or leading zeros
                        if leading_zeros_count >= prec.i64 {
                            // All digits are leading zeros
                            let leading_zeros = Array::fill(prec.i64, "0").to_iter.fold("", |s, acc| acc + s);
                            sign + "0." + leading_zeros
                        } else {
                            // Some mantissa digits fit
                            let available_for_mantissa = prec.i64 - leading_zeros_count;
                            let mantissa_part = if available_for_mantissa > 0 {
                                get_sub(0, available_for_mantissa, mantissa)
                            } else {
                                ""
                            };
                            let leading_zeros = Array::fill(leading_zeros_count, "0").to_iter.fold("", |s, acc| acc + s);
                            sign + "0." + leading_zeros + mantissa_part
                        }
                    }
                }
            }
        }
    );

    // Arithmetic operations

    // Add two MPFR numbers.
    // Uses RNDN rounding and precision is the maximum of the two operands.
    // 
    // # Parameters
    // - `lhs`: The left-hand side operand.
    // - `rhs`: The right-hand side operand.
    add : MPFR -> MPFR -> MPFR;
    add = |lhs, rhs| (
        let prec = if lhs.get_prec >= rhs.get_prec { lhs.get_prec } else { rhs.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, lhs_ptr, rhs_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_add(Ptr, Ptr, Ptr, CInt), out_ptr, lhs_ptr, rhs_ptr, rnd],
            lhs, rhs
        );
        num
    );

    // Subtract two MPFR numbers.
    // Uses RNDN rounding and precision is the maximum of the two operands.
    // 
    // # Parameters
    // - `lhs`: The left-hand side operand.
    // - `rhs`: The right-hand side operand.
    sub : MPFR -> MPFR -> MPFR;
    sub = |lhs, rhs| (
        let prec = if lhs.get_prec >= rhs.get_prec { lhs.get_prec } else { rhs.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, lhs_ptr, rhs_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sub(Ptr, Ptr, Ptr, CInt), out_ptr, lhs_ptr, rhs_ptr, rnd],
            lhs, rhs
        );
        num
    );

    // Multiply two MPFR numbers.
    // Uses RNDN rounding and precision is the maximum of the two operands.
    // 
    // # Parameters
    // - `lhs`: The left-hand side operand.
    // - `rhs`: The right-hand side operand.
    mul : MPFR -> MPFR -> MPFR;
    mul = |lhs, rhs| (
        let prec = if lhs.get_prec >= rhs.get_prec { lhs.get_prec } else { rhs.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, lhs_ptr, rhs_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_mul(Ptr, Ptr, Ptr, CInt), out_ptr, lhs_ptr, rhs_ptr, rnd],
            lhs, rhs
        );
        num
    );

    // Divide two MPFR numbers.
    // Uses RNDN rounding and precision is the maximum of the two operands.
    // 
    // # Parameters
    // - `lhs`: The left-hand side operand (dividend).
    // - `rhs`: The right-hand side operand (divisor).
    div : MPFR -> MPFR -> MPFR;
    div = |lhs, rhs| (
        let prec = if lhs.get_prec >= rhs.get_prec { lhs.get_prec } else { rhs.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, lhs_ptr, rhs_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_div(Ptr, Ptr, Ptr, CInt), out_ptr, lhs_ptr, rhs_ptr, rnd],
            lhs, rhs
        );
        num
    );

    // Negate an MPFR number (exact operation).
    // 
    // # Parameters
    // - `x`: The number to negate.
    neg : MPFR -> MPFR;
    neg = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_neg(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Absolute value of an MPFR number (exact operation).
    // 
    // # Parameters
    // - `x`: The number to take absolute value of.
    abs : MPFR -> MPFR;
    abs = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_abs(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Square an MPFR number.
    // 
    // # Parameters
    // - `x`: The number to square.
    sqr : MPFR -> MPFR;
    sqr = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sqr(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Square root of an MPFR number.
    // 
    // # Parameters
    // - `x`: The number to take square root of.
    sqrt : MPFR -> MPFR;
    sqrt = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sqrt(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Reciprocal square root of an MPFR number.
    // 
    // # Parameters
    // - `x`: The number to take reciprocal square root of (1/sqrt(x)).
    rec_sqrt : MPFR -> MPFR;
    rec_sqrt = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_rec_sqrt(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Cube root of an MPFR number.
    // 
    // # Parameters
    // - `x`: The number to take cube root of.
    cbrt : MPFR -> MPFR;
    cbrt = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_cbrt(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // N-th root of an MPFR number.
    // 
    // # Parameters
    // - `n`: The degree of the root (must be > 0).
    // - `x`: The number to take n-th root of.
    rootn_ui : U64 -> MPFR -> MPFR;
    rootn_ui = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_rootn_ui(Ptr, Ptr, CUnsignedLong, CInt), 
                    out_ptr, num_ptr, n.c_unsigned_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Power function: base^exponent.
    // 
    // # Parameters
    // - `base`: The base.
    // - `exponent`: The exponent.
    pow : MPFR -> MPFR -> MPFR;
    pow = |base, exp| (
        let prec = if base.get_prec >= exp.get_prec { base.get_prec } else { exp.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, base_ptr, exp_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_pow(Ptr, Ptr, Ptr, CInt), out_ptr, base_ptr, exp_ptr, rnd],
            base, exp
        );
        num
    );

    // Power function with unsigned integer exponent.
    // 
    // # Parameters
    // - `exponent`: The unsigned integer exponent.
    // - `base`: The base.
    pow_ui : U64 -> MPFR -> MPFR;
    pow_ui = |exp, base| (
        let (result, _) = base._borrow(|base_ptr|
            MPFR::_init_by(base.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_pow_ui(Ptr, Ptr, CUnsignedLong, CInt), 
                    out_ptr, base_ptr, exp.c_unsigned_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Power function with signed integer exponent.
    // 
    // # Parameters
    // - `exponent`: The signed integer exponent.
    // - `base`: The base.
    pow_si : I64 -> MPFR -> MPFR;
    pow_si = |exp, base| (
        let (result, _) = base._borrow(|base_ptr|
            MPFR::_init_by(base.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_pow_si(Ptr, Ptr, CLong, CInt), 
                    out_ptr, base_ptr, exp.c_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Multiply by 2^n (efficient bit shift).
    // 
    // # Parameters
    // - `n`: The exponent (unsigned).
    // - `x`: The number to multiply.
    mul_2ui : U64 -> MPFR -> MPFR;
    mul_2ui = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_mul_2ui(Ptr, Ptr, CUnsignedLong, CInt), 
                    out_ptr, num_ptr, n.c_unsigned_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Multiply by 2^n where n can be negative (efficient bit shift).
    // 
    // # Parameters
    // - `n`: The exponent (signed).
    // - `x`: The number to multiply.
    mul_2si : I64 -> MPFR -> MPFR;
    mul_2si = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_mul_2si(Ptr, Ptr, CLong, CInt), 
                    out_ptr, num_ptr, n.c_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Divide by 2^n (efficient bit shift).
    // 
    // # Parameters
    // - `n`: The exponent (unsigned).
    // - `x`: The number to divide.
    div_2ui : U64 -> MPFR -> MPFR;
    div_2ui = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_div_2ui(Ptr, Ptr, CUnsignedLong, CInt), 
                    out_ptr, num_ptr, n.c_unsigned_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Divide by 2^n where n can be negative (efficient bit shift).
    // 
    // # Parameters
    // - `n`: The exponent (signed).
    // - `x`: The number to divide.
    div_2si : I64 -> MPFR -> MPFR;
    div_2si = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_div_2si(Ptr, Ptr, CLong, CInt), 
                    out_ptr, num_ptr, n.c_long, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Exponential function.
    // 
    // # Parameters
    // - `x`: The number to exponentiate.
    exp : MPFR -> MPFR;
    exp = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_exp(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Natural logarithm.
    // 
    // # Parameters
    // - `x`: The number to take logarithm of.
    log : MPFR -> MPFR;
    log = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_log(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Base-2 logarithm.
    // 
    // # Parameters
    // - `x`: The number to take logarithm of.
    log2 : MPFR -> MPFR;
    log2 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_log2(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Base-10 logarithm.
    // 
    // # Parameters
    // - `x`: The number to take logarithm of.
    log10 : MPFR -> MPFR;
    log10 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_log10(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Base-2 exponential function (2^x).
    // 
    // # Parameters
    // - `x`: The exponent.
    exp2 : MPFR -> MPFR;
    exp2 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_exp2(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Base-10 exponential function (10^x).
    // 
    // # Parameters
    // - `x`: The exponent.
    exp10 : MPFR -> MPFR;
    exp10 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_exp10(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // exp(x) - 1, computed accurately even for small x.
    // 
    // # Parameters
    // - `x`: The number to exponentiate.
    expm1 : MPFR -> MPFR;
    expm1 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_expm1(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // log(1 + x), computed accurately even for small x.
    // 
    // # Parameters
    // - `x`: The number to add to 1 before taking logarithm.
    log1p : MPFR -> MPFR;
    log1p = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_log1p(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Sine function.
    // 
    // # Parameters
    // - `x`: The angle in radians.
    sin : MPFR -> MPFR;
    sin = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sin(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Cosine function.
    // 
    // # Parameters
    // - `x`: The angle in radians.
    cos : MPFR -> MPFR;
    cos = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_cos(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Tangent function.
    // 
    // # Parameters
    // - `x`: The angle in radians.
    tan : MPFR -> MPFR;
    tan = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_tan(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Arcsine function.
    // 
    // # Parameters
    // - `x`: The value (must be in [-1, 1]).
    asin : MPFR -> MPFR;
    asin = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_asin(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Arccosine function.
    // 
    // # Parameters
    // - `x`: The value (must be in [-1, 1]).
    acos : MPFR -> MPFR;
    acos = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_acos(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Arctangent function.
    // 
    // # Parameters
    // - `x`: The value.
    atan : MPFR -> MPFR;
    atan = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_atan(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Secant function: sec(x) = 1/cos(x).
    // 
    // # Parameters
    // - `x`: The angle in radians.
    sec : MPFR -> MPFR;
    sec = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sec(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Cosecant function: csc(x) = 1/sin(x).
    // 
    // # Parameters
    // - `x`: The angle in radians.
    csc : MPFR -> MPFR;
    csc = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_csc(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Cotangent function: cot(x) = 1/tan(x).
    // 
    // # Parameters
    // - `x`: The angle in radians.
    cot : MPFR -> MPFR;
    cot = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_cot(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Two-argument arctangent function (atan2).
    // 
    // # Parameters
    // - `y`: The y coordinate.
    // - `x`: The x coordinate.
    atan2 : MPFR -> MPFR -> MPFR;
    atan2 = |y, x| (
        let prec = if y.get_prec >= x.get_prec { y.get_prec } else { x.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, y_ptr, x_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_atan2(Ptr, Ptr, Ptr, CInt), out_ptr, y_ptr, x_ptr, rnd],
            y, x
        );
        num
    );

    // Mathematical constant Pi.
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    const_pi : Precision -> MPFR;
    const_pi = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_const_pi(Ptr, CInt), ptr, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Mathematical constant log(2).
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    const_log2 : Precision -> MPFR;
    const_log2 = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_const_log2(Ptr, CInt), ptr, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Mathematical constant Euler's constant (0.577...).
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    const_euler : Precision -> MPFR;
    const_euler = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_const_euler(Ptr, CInt), ptr, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Mathematical constant Catalan's constant (0.915...).
    // 
    // # Parameters
    // - `prec`: The precision in bits.
    const_catalan : Precision -> MPFR;
    const_catalan = |prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_const_catalan(Ptr, CInt), ptr, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Test if the sign bit is set (even for NaN and zero).
    // 
    // # Parameters
    // - `x`: The number to check sign bit of.
    signbit : MPFR -> Bool;
    signbit = |num| (
        num._borrow(|ptr| FFI_CALL[CInt mpfr_signbit(Ptr), ptr] != 0.c_int)
    );

    // Copy the sign of y to x.
    // 
    // # Parameters
    // - `x`: The number to copy magnitude from.
    // - `y`: The number to copy sign from.
    copysign : MPFR -> MPFR -> MPFR;
    copysign = |x, y| (
        let prec = x.get_prec;
        let (result, _) = x._borrow(|x_ptr|
            y._borrow(|y_ptr|
                MPFR::_init_by(prec, |out_ptr| 
                    FFI_CALL_IO[CInt mpfr_copysign(Ptr, Ptr, Ptr, CInt), 
                        out_ptr, x_ptr, y_ptr, RoundMode::rndn().to_c_rnd]
                )
            )
        );
        result
    );

    // Set the sign of x according to the boolean s (false = positive, true = negative).
    // 
    // # Parameters
    // - `sign`: The sign to set (false for positive, true for negative).
    // - `x`: The number to set sign of.
    setsign : Bool -> MPFR -> MPFR;
    setsign = |s, num| (
        let sign = if s { 1.c_int } else { 0.c_int };
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_setsign(Ptr, Ptr, CInt, CInt), 
                    out_ptr, num_ptr, sign, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Return the next floating-point number in the direction of y.
    // 
    // # Parameters
    // - `x`: The starting number.
    // - `direction`: The direction to move toward.
    nexttoward : MPFR -> MPFR -> MPFR;
    nexttoward = |x, y| (
        let (result, _) = x._borrow(|x_ptr|
            y._borrow(|y_ptr|
                x._mutate(|out_ptr| 
                    FFI_CALL_IO[() mpfr_nexttoward(Ptr, Ptr), out_ptr, y_ptr];;
                    pure $ 0.c_int
                )
            )
        );
        result
    );

    // Return the next floating-point number toward +infinity.
    // 
    // # Parameters
    // - `x`: The starting number.
    nextabove : MPFR -> MPFR;
    nextabove = |num| (
        let (result, _) = num._mutate(|num_ptr|
            FFI_CALL_IO[() mpfr_nextabove(Ptr), num_ptr];;
            pure $ 0.c_int
        );
        result
    );

    // Return the next floating-point number toward -infinity.
    // 
    // # Parameters
    // - `x`: The starting number.
    nextbelow : MPFR -> MPFR;
    nextbelow = |num| (
        let (result, _) = num._mutate(|num_ptr|
            FFI_CALL_IO[() mpfr_nextbelow(Ptr), num_ptr];;
            pure $ 0.c_int
        );
        result
    );

    // Hyperbolic sine function.
    // 
    // # Parameters
    // - `x`: The value.
    sinh : MPFR -> MPFR;
    sinh = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sinh(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Hyperbolic cosine function.
    // 
    // # Parameters
    // - `x`: The value.
    cosh : MPFR -> MPFR;
    cosh = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_cosh(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Hyperbolic tangent function.
    // 
    // # Parameters
    // - `x`: The value.
    tanh : MPFR -> MPFR;
    tanh = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_tanh(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Inverse hyperbolic sine function.
    // 
    // # Parameters
    // - `x`: The value.
    asinh : MPFR -> MPFR;
    asinh = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_asinh(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Inverse hyperbolic cosine function.
    // 
    // # Parameters
    // - `x`: The value (must be >= 1).
    acosh : MPFR -> MPFR;
    acosh = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_acosh(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Inverse hyperbolic tangent function.
    // 
    // # Parameters
    // - `x`: The value (must be in (-1, 1)).
    atanh : MPFR -> MPFR;
    atanh = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_atanh(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Hyperbolic secant function: sech(x) = 1/cosh(x).
    // 
    // # Parameters
    // - `x`: The value.
    sech : MPFR -> MPFR;
    sech = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_sech(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Hyperbolic cosecant function: csch(x) = 1/sinh(x).
    // 
    // # Parameters
    // - `x`: The value.
    csch : MPFR -> MPFR;
    csch = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_csch(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Hyperbolic cotangent function: coth(x) = 1/tanh(x).
    // 
    // # Parameters
    // - `x`: The value.
    coth : MPFR -> MPFR;
    coth = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_coth(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Gamma function.
    // 
    // # Parameters
    // - `x`: The value.
    gamma : MPFR -> MPFR;
    gamma = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_gamma(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Natural logarithm of the absolute value of the Gamma function.
    // 
    // # Parameters
    // - `x`: The value.
    lngamma : MPFR -> MPFR;
    lngamma = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_lngamma(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Error function.
    // 
    // # Parameters
    // - `x`: The value.
    erf : MPFR -> MPFR;
    erf = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_erf(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Complementary error function.
    // 
    // # Parameters
    // - `x`: The value.
    erfc : MPFR -> MPFR;
    erfc = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_erfc(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Riemann zeta function.
    // 
    // # Parameters
    // - `x`: The value.
    zeta : MPFR -> MPFR;
    zeta = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_zeta(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Riemann zeta function for unsigned integer argument.
    // 
    // # Parameters
    // - `n`: The unsigned integer argument.
    // - `prec`: The precision in bits.
    zeta_ui : U64 -> Precision -> MPFR;
    zeta_ui = |n, prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_zeta_ui(Ptr, CUnsignedLong, CInt), 
                ptr, n.c_unsigned_long, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Beta function: B(x, y) = Γ(x)Γ(y)/Γ(x+y).
    // 
    // # Parameters
    // - `x`: The first parameter.
    // - `y`: The second parameter.
    beta : MPFR -> MPFR -> MPFR;
    beta = |x, y| (
        let prec = if x.get_prec >= y.get_prec { x.get_prec } else { y.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, x_ptr, y_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_beta(Ptr, Ptr, Ptr, CInt), out_ptr, x_ptr, y_ptr, rnd],
            x, y
        );
        num
    );

    // Digamma function (psi function): ψ(x) = Γ'(x)/Γ(x).
    // 
    // # Parameters
    // - `x`: The value.
    digamma : MPFR -> MPFR;
    digamma = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_digamma(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Bessel function of the first kind of order 0.
    // 
    // # Parameters
    // - `x`: The value.
    j0 : MPFR -> MPFR;
    j0 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_j0(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Bessel function of the first kind of order 1.
    // 
    // # Parameters
    // - `x`: The value.
    j1 : MPFR -> MPFR;
    j1 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_j1(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Bessel function of the first kind of order n.
    // 
    // # Parameters
    // - `n`: The order.
    // - `x`: The value.
    jn : I64 -> MPFR -> MPFR;
    jn = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_jn(Ptr, CLong, Ptr, CInt), 
                    out_ptr, n.c_long, num_ptr, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Bessel function of the second kind of order 0.
    // 
    // # Parameters
    // - `x`: The value.
    y0 : MPFR -> MPFR;
    y0 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_y0(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Bessel function of the second kind of order 1.
    // 
    // # Parameters
    // - `x`: The value.
    y1 : MPFR -> MPFR;
    y1 = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_y1(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Bessel function of the second kind of order n.
    // 
    // # Parameters
    // - `n`: The order.
    // - `x`: The value.
    yn : I64 -> MPFR -> MPFR;
    yn = |n, num| (
        let (result, _) = num._borrow(|num_ptr|
            MPFR::_init_by(num.get_prec, |out_ptr| 
                FFI_CALL_IO[CInt mpfr_yn(Ptr, CLong, Ptr, CInt), 
                    out_ptr, n.c_long, num_ptr, RoundMode::rndn().to_c_rnd]
            )
        );
        result
    );

    // Airy function Ai(x).
    // 
    // # Parameters
    // - `x`: The value.
    ai : MPFR -> MPFR;
    ai = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_ai(Ptr, Ptr, CInt), out_ptr, num_ptr, rnd],
            num
        );
        result
    );

    // Integer and rounding functions

    // Round to the next higher integer.
    // 
    // # Parameters
    // - `x`: The number to round up.
    ceil : MPFR -> MPFR;
    ceil = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_ceil(Ptr, Ptr), out_ptr, num_ptr],
            num
        );
        result
    );

    // Round to the next lower integer.
    // 
    // # Parameters
    // - `x`: The number to round down.
    floor : MPFR -> MPFR;
    floor = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_floor(Ptr, Ptr), out_ptr, num_ptr],
            num
        );
        result
    );

    // Round to the nearest integer, rounding halfway cases away from zero.
    // 
    // # Parameters
    // - `x`: The number to round.
    round : MPFR -> MPFR;
    round = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_round(Ptr, Ptr), out_ptr, num_ptr],
            num
        );
        result
    );

    // Round to the next integer toward zero.
    // 
    // # Parameters
    // - `x`: The number to truncate.
    trunc : MPFR -> MPFR;
    trunc = |num| (
        let (result, _) = _unary_op(RoundMode::rndn(), 
            |(out_ptr, num_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_trunc(Ptr, Ptr), out_ptr, num_ptr],
            num
        );
        result
    );

    // Miscellaneous functions

    // Return the minimum of two MPFR numbers.
    // 
    // # Parameters
    // - `x`: The first number.
    // - `y`: The second number.
    min : MPFR -> MPFR -> MPFR;
    min = |lhs, rhs| (
        let prec = if lhs.get_prec >= rhs.get_prec { lhs.get_prec } else { rhs.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, lhs_ptr, rhs_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_min(Ptr, Ptr, Ptr, CInt), out_ptr, lhs_ptr, rhs_ptr, rnd],
            lhs, rhs
        );
        num
    );

    // Return the maximum of two MPFR numbers.
    // 
    // # Parameters
    // - `x`: The first number.
    // - `y`: The second number.
    max : MPFR -> MPFR -> MPFR;
    max = |lhs, rhs| (
        let prec = if lhs.get_prec >= rhs.get_prec { lhs.get_prec } else { rhs.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, lhs_ptr, rhs_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_max(Ptr, Ptr, Ptr, CInt), out_ptr, lhs_ptr, rhs_ptr, rnd],
            lhs, rhs
        );
        num
    );

    // Fused multiply-add: (x * y) + z, computed with a single rounding.
    // 
    // # Parameters
    // - `x`: The first multiplicand.
    // - `y`: The second multiplicand.
    // - `z`: The addend.
    fma : MPFR -> MPFR -> MPFR -> MPFR;
    fma = |x, y, z| (
        let prec = [x.get_prec, y.get_prec, z.get_prec].to_iter.fold(0, max);
        let rnd_c = RoundMode::rndn().to_c_rnd;
        x._borrow(|x_ptr|
            y._borrow(|y_ptr|
                z._borrow(|z_ptr|
                    MPFR::_init_by(prec, |out_ptr| 
                        FFI_CALL_IO[CInt mpfr_fma(Ptr, Ptr, Ptr, Ptr, CInt), 
                            out_ptr, x_ptr, y_ptr, z_ptr, rnd_c]
                    )
                )
            )
        ).@0
    );

    // Euclidean norm: sqrt(x^2 + y^2), computed without intermediate overflow or underflow.
    // 
    // # Parameters
    // - `x`: The first component.
    // - `y`: The second component.
    hypot : MPFR -> MPFR -> MPFR;
    hypot = |x, y| (
        let prec = if x.get_prec >= y.get_prec { x.get_prec } else { y.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, x_ptr, y_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_hypot(Ptr, Ptr, Ptr, CInt), out_ptr, x_ptr, y_ptr, rnd],
            x, y
        );
        num
    );

    // Arithmetic-geometric mean of two MPFR numbers.
    // 
    // # Parameters
    // - `x`: The first number.
    // - `y`: The second number.
    agm : MPFR -> MPFR -> MPFR;
    agm = |x, y| (
        let prec = if x.get_prec >= y.get_prec { x.get_prec } else { y.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, x_ptr, y_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_agm(Ptr, Ptr, Ptr, CInt), out_ptr, x_ptr, y_ptr, rnd],
            x, y
        );
        num
    );

    // Factorial function: n!
    // 
    // # Parameters
    // - `n`: The non-negative integer to compute factorial of.
    // - `prec`: The precision in bits.
    fac_ui : U64 -> Precision -> MPFR;
    fac_ui = |n, prec| (
        let (num, _) = MPFR::_init_by(prec, |ptr| 
            FFI_CALL_IO[CInt mpfr_fac_ui(Ptr, CUnsignedLong, CInt), 
                ptr, n.c_unsigned_long, RoundMode::rndn().to_c_rnd]
        );
        num
    );

    // Floating-point remainder: x - n*y where n is the integer quotient x/y rounded toward zero.
    // 
    // # Parameters
    // - `x`: The dividend.
    // - `y`: The divisor.
    fmod : MPFR -> MPFR -> MPFR;
    fmod = |x, y| (
        let prec = if x.get_prec >= y.get_prec { x.get_prec } else { y.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, x_ptr, y_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_fmod(Ptr, Ptr, Ptr, CInt), out_ptr, x_ptr, y_ptr, rnd],
            x, y
        );
        num
    );

    // IEEE remainder: x - n*y where n is the integer quotient x/y rounded to nearest.
    // 
    // # Parameters
    // - `x`: The dividend.
    // - `y`: The divisor.
    remainder : MPFR -> MPFR -> MPFR;
    remainder = |x, y| (
        let prec = if x.get_prec >= y.get_prec { x.get_prec } else { y.get_prec };
        let (num, _) = _binary_op(RoundMode::rndn(), prec, 
            |(out_ptr, x_ptr, y_ptr, rnd)| 
                FFI_CALL_IO[CInt mpfr_remainder(Ptr, Ptr, Ptr, CInt), out_ptr, x_ptr, y_ptr, rnd],
            x, y
        );
        num
    );

    // Comparison functions

    // Compare two MPFR numbers.
    // Returns negative if lhs < rhs, zero if lhs == rhs, positive if lhs > rhs.
    // 
    // # Parameters
    // - `lhs`: The left-hand side number.
    // - `rhs`: The right-hand side number.
    cmp : MPFR -> MPFR -> I64;
    cmp = |lhs, rhs| (
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                FFI_CALL[CInt mpfr_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr].i64
            )
        )
    );

    // Check if two MPFR numbers are equal.
    // 
    // # Parameters
    // - `lhs`: The left-hand side number.
    // - `rhs`: The right-hand side number.
    equal : MPFR -> MPFR -> Bool;
    equal = |lhs, rhs| (
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                FFI_CALL[CInt mpfr_equal_p(Ptr, Ptr), lhs_ptr, rhs_ptr] != 0.c_int
            )
        )
    );

    // Check if lhs < rhs.
    // 
    // # Parameters
    // - `lhs`: The left-hand side number.
    // - `rhs`: The right-hand side number.
    less : MPFR -> MPFR -> Bool;
    less = |lhs, rhs| (
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                FFI_CALL[CInt mpfr_less_p(Ptr, Ptr), lhs_ptr, rhs_ptr] != 0.c_int
            )
        )
    );

    // Check if lhs <= rhs.
    // 
    // # Parameters
    // - `lhs`: The left-hand side number.
    // - `rhs`: The right-hand side number.
    lesseq : MPFR -> MPFR -> Bool;
    lesseq = |lhs, rhs| (
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                FFI_CALL[CInt mpfr_lessequal_p(Ptr, Ptr), lhs_ptr, rhs_ptr] != 0.c_int
            )
        )
    );

    // Special value predicates

    // Check if the value is NaN.
    // 
    // # Parameters
    // - `x`: The number to check.
    is_nan : MPFR -> Bool;
    is_nan = |num| (
        num._borrow(|ptr| FFI_CALL[CInt mpfr_nan_p(Ptr), ptr] != 0.c_int)
    );

    // Check if the value is infinite.
    // 
    // # Parameters
    // - `x`: The number to check.
    is_inf : MPFR -> Bool;
    is_inf = |num| (
        num._borrow(|ptr| FFI_CALL[CInt mpfr_inf_p(Ptr), ptr] != 0.c_int)
    );

    // Check if the value is a regular number (not NaN, not Inf).
    // 
    // # Parameters
    // - `x`: The number to check.
    is_number : MPFR -> Bool;
    is_number = |num| (
        num._borrow(|ptr| FFI_CALL[CInt mpfr_number_p(Ptr), ptr] != 0.c_int)
    );

    // Check if the value is zero.
    // 
    // # Parameters
    // - `x`: The number to check.
    is_zero : MPFR -> Bool;
    is_zero = |num| (
        num._borrow(|ptr| FFI_CALL[CInt mpfr_zero_p(Ptr), ptr] != 0.c_int)
    );

    // Get the sign of a number.
    // Returns negative if num < 0, zero if num == 0, positive if num > 0.
    // 
    // # Parameters
    // - `x`: The number to get sign of.
    sgn : MPFR -> I64;
    sgn = |num| (
        num._borrow(|ptr| FFI_CALL[CInt mpfr_sgn(Ptr), ptr].i64)
    );
}

// Trait implementations

impl MPFR : Zero {
    zero = MPFR::zero(53);
}

impl MPFR : Add {
    add = MPFR::add;
}

impl MPFR : Sub {
    sub = MPFR::sub;
}

impl MPFR : Mul {
    mul = MPFR::mul;
}

impl MPFR : Div {
    div = MPFR::div;
}

impl MPFR : Neg {
    neg = MPFR::neg;
}

impl MPFR : Eq {
    eq = MPFR::equal;
}

impl MPFR : LessThan {
    less_than = MPFR::less;
}

impl MPFR : LessThanOrEq {
    less_than_or_eq = MPFR::lesseq;
}

impl MPFR : ToString {
    to_string = |num| (
        let (mantissa, exp) = num.get_str(10, 0, RoundMode::rndn());
        
        // Handle special values (check if contains '@')
        if mantissa.to_iter_bytes.check_any(|c| c == '@') {
            mantissa
        } else {
            // Handle sign
            let (sign, mantissa) = if mantissa.starts_with("-") {
                ("-", get_sub(1, @size(mantissa), mantissa))
            } else {
                ("", mantissa)
            };
            
            // Handle zero - check if mantissa is empty or all zeros
            let is_zero = mantissa == "" || mantissa.to_iter_bytes.check_all(|c| c == '0');
            if is_zero {
                sign + "0"
            } else {
                // Remove trailing zeros from mantissa
                let mantissa = mantissa.strip_last_bytes(|c| c == '0');
                let len = @size(mantissa);
                
                // If mantissa became empty after removing zeros, it was all zeros
                if len == 0 {
                    sign + "0"
                } else {
                    // Format based on exponent
                    // Use scientific notation for very large or very small exponents
                    let use_scientific = (exp > len + 6) || (exp < -6);
                    
                    if use_scientific {
                        // Scientific notation: "1.23e+100"
                        let first_char = if @size(mantissa) > 0 { get_sub(0, 1, mantissa) } else { "" };
                        let rest = if @size(mantissa) > 1 { get_sub(1, len, mantissa) } else { "" };
                        let significand = if rest == "" { first_char } else { first_char + "." + rest };
                        sign + significand + "e" + (exp - 1).to_string
                    } else if exp > len {
                        // Integer with trailing zeros (e.g., "1" with exp=2 -> "10")
                        let trailing_zeros_count = exp - len;
                        let trailing_zeros = Array::fill(trailing_zeros_count.i64, "0").to_iter.fold("", |s, acc| acc + s);
                        sign + mantissa + trailing_zeros
                    } else if exp == len {
                        // Integer without trailing zeros (e.g., "314" with exp=3 -> "314")
                        sign + mantissa
                    } else if exp >= 1 && exp < len {
                        // Insert decimal point within the mantissa (e.g., "314" with exp=1 -> "3.14")
                        sign + get_sub(0, exp, mantissa) + "." + get_sub(exp, len, mantissa)
                    } else if exp <= 0 {
                        // Small number with leading zeros (e.g., "314" with exp=-2 -> "0.00314")
                        let zeros = Array::fill((-exp).i64, "0").to_iter.fold("", |s, acc| acc + s);
                        sign + "0." + zeros + mantissa
                    } else {
                        // This branch should not be reached
                        sign + mantissa
                    }
                }
            }
        }
    );
}
