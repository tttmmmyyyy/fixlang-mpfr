// Tests for MPFR module
module Test;

import MPFR::MPFR::{
    abs, add, asin, asinh, atan2, cbrt, ceil, cmp, const_catalan, const_euler, const_log2, const_pi, 
    copysign, cos, cosh, digamma, div, div_2si, div_2ui, erf, erfc, exp, exp10, exp2, expm1, fac_ui, 
    floor, fma, fmod, gamma, get_f64, get_prec, get_si, get_str, get_str_ndigits, get_ui, hypot, inf, 
    is_inf, is_nan, is_number, is_zero, j0, j1, lngamma, log, log10, log1p, log2, max, min, mpfr, mpfr_i, 
    mpfr_str, mpfr_ui, mul_2ui, nan, neg_inf, pow, pow_ui, rootn_ui, round, sec, sech, sgn, signbit, sin, 
    sinh, sqr, sqrt, sub, tanh, to_string_digits, to_string_exp, to_string_exp_digits, to_string_exp_precision, to_string_precision, trunc, zero, zeta_ui
};
import MPFR::RoundMode::{rndn};
import Std::{F64, IO, Array::{pop_back, to_iter}, Debug::{assert, assert_eq}, F64::abs, IO::println, Iterator::check_any, Monad::pure, Option::{as_some, is_none, is_some}, String::{get_bytes, starts_with, to_iter_bytes}, ToString::to_string};

test_basic_construction : IO ();
test_basic_construction = (
    // Test mpfr from I64
    let x = MPFR::mpfr_i(53, 42);
    assert_eq(|_|"mpfr from I64", x.get_si.as_some, 42);;

    // Test mpfr from U64
    let y = MPFR::mpfr_ui(53, 100_U64);
    assert_eq(|_|"mpfr from U64", y.get_ui.as_some, 100_U64);;

    // Test mpfr from F64
    let z = MPFR::mpfr(113, 3.14159);
    let z_f64 = z.get_f64;
    assert(|_|"mpfr from F64", (z_f64 - 3.14159).abs < 0.00001);;

    // Test special values
    let zero_val = MPFR::zero(53);
    assert(|_|"zero is_zero", zero_val.is_zero);;
    
    let nan_val = MPFR::nan(53);
    assert(|_|"nan is_nan", nan_val.is_nan);;
    
    let inf_val = MPFR::inf(53);
    assert(|_|"inf is_inf", inf_val.is_inf);;
    
    let neg_inf_val = MPFR::neg_inf(53);
    assert(|_|"neg_inf is_inf", neg_inf_val.is_inf);;
    assert_eq(|_|"neg_inf sgn", neg_inf_val.sgn, -1);;

    pure()
);

test_arithmetic : IO ();
test_arithmetic = (
    let x = MPFR::mpfr_i(113, 10);
    let y = MPFR::mpfr_i(113, 3);

    // Test addition
    let sum = x + y;
    assert_eq(|_|"10 + 3", sum.get_si.as_some, 13);;

    // Test subtraction
    let diff = x - y;
    assert_eq(|_|"10 - 3", diff.get_si.as_some, 7);;

    // Test multiplication
    let prod = x * y;
    assert_eq(|_|"10 * 3", prod.get_si.as_some, 30);;

    // Test division
    let quot = x / y;
    let quot_f64 = quot.get_f64;
    assert(|_|"10 / 3", (quot_f64 - 3.333333).abs < 0.00001);;

    // Test negation
    let neg_x = -x;
    assert_eq(|_|"negation", neg_x.get_si.as_some, -10);;

    // Test absolute value
    let abs_neg = MPFR::abs(neg_x);
    assert_eq(|_|"abs(-10)", abs_neg.get_si.as_some, 10);;

    pure()
);

test_comparison : IO ();
test_comparison = (
    let x = MPFR::mpfr_i(53, 10);
    let y = MPFR::mpfr_i(53, 20);
    let z = MPFR::mpfr_i(53, 10);

    // Test equality
    assert(|_|"x == z", x == z);;
    assert(|_|"x != y", !(x == y));;

    // Test less than
    assert(|_|"x < y", x < y);;
    assert(|_|"!(y < x)", !(y < x));;

    // Test less than or equal
    assert(|_|"x <= z", x <= z);;
    assert(|_|"x <= y", x <= y);;

    // Test cmp - use MPFR::cmp(lhs, rhs) not x.cmp(y)
    assert_eq(|_|"cmp x z", MPFR::cmp(x, z), 0);;
    assert(|_|"cmp x y < 0", MPFR::cmp(x, y) < 0);;
    assert(|_|"cmp y x > 0", MPFR::cmp(y, x) > 0);;

    pure()
);

test_conversion : IO ();
test_conversion = (
    // Test I64 conversion
    let x = MPFR::mpfr_i(53, 12345);
    assert_eq(|_|"MPFR to I64", x.get_si.as_some, 12345);;

    // Test U64 conversion
    let y = MPFR::mpfr_ui(53, 67890_U64);
    assert_eq(|_|"MPFR to U64", y.get_ui.as_some, 67890_U64);;

    // Test F64 conversion
    let z = MPFR::mpfr(113, 2.718281828);
    let z_f64 = z.get_f64;
    assert(|_|"MPFR to F64", (z_f64 - 2.718281828).abs < 0.00000001);;

    pure()
);

test_special_values : IO ();
test_special_values = (
    let normal = MPFR::mpfr_i(53, 42);
    let nan_val = MPFR::nan(53);
    let inf_val = MPFR::inf(53);
    let zero_val = MPFR::zero(53);

    // Test predicates on normal value
    assert(|_|"normal.is_number", normal.is_number);;
    assert(|_|"!normal.is_nan", !normal.is_nan);;
    assert(|_|"!normal.is_inf", !normal.is_inf);;
    assert(|_|"!normal.is_zero", !normal.is_zero);;

    // Test predicates on special values
    assert(|_|"nan.is_nan", nan_val.is_nan);;
    assert(|_|"inf.is_inf", inf_val.is_inf);;
    assert(|_|"zero.is_zero", zero_val.is_zero);;

    // Test sign
    let pos = MPFR::mpfr_i(53, 10);
    let neg = MPFR::mpfr_i(53, -10);
    assert(|_|"sgn(10) > 0", pos.sgn > 0);;
    assert(|_|"sgn(-10) < 0", neg.sgn < 0);;
    assert_eq(|_|"sgn(0)", zero_val.sgn, 0);;

    pure()
);

test_precision : IO ();
test_precision = (
    let x53 = MPFR::mpfr_i(53, 1);
    let x113 = MPFR::mpfr_i(113, 1);
    let x256 = MPFR::mpfr_i(256, 1);

    assert_eq(|_|"precision 53", x53.get_prec, 53);;
    assert_eq(|_|"precision 113", x113.get_prec, 113);;
    assert_eq(|_|"precision 256", x256.get_prec, 256);;

    // Test that operations preserve maximum precision
    let sum = x53 + x113;
    assert_eq(|_|"precision after add", sum.get_prec, 113);;

    pure()
);

test_string_conversion : IO ();
test_string_conversion = (
    // Test mpfr_str
    let from_str = MPFR::mpfr_str(113, "123.456", 10);
    assert(|_|"from_str success", from_str.is_some);;
    let val = from_str.as_some;
    let val_f64 = val.get_f64;
    assert(|_|"from_str value", (val_f64 - 123.456).abs < 0.001);;

    // Test hex string
    let from_hex = MPFR::mpfr_str(113, "1A.5", 16);
    assert(|_|"from_hex success", from_hex.is_some);;
    let hex_val = from_hex.as_some;
    let hex_f64 = hex_val.get_f64;
    assert(|_|"from_hex value", (hex_f64 - 26.3125).abs < 0.001);;

    // Test invalid string
    let invalid = MPFR::mpfr_str(113, "invalid", 10);
    assert(|_|"invalid string fails", invalid.is_none);;

    pure()
);

test_string_output : IO ();
test_string_output = (
    // Test get_str_ndigits
    let ndigits = MPFR::get_str_ndigits(10, 113);
    assert(|_|"get_str_ndigits(10, 113) returns expected value", ndigits == 36);;
    
    // Test get_str with pi
    let pi = MPFR::const_pi(113);
    let (pi_mantissa, pi_exp) = pi.get_str(10, 10, rndn());
    assert(|_|"pi mantissa with 10 digits", pi_mantissa == "3141592654");;
    assert(|_|"pi exponent", pi_exp == 1);;
    
    // Test get_str with a simple integer
    let x = MPFR::mpfr_i(113, 123);
    let (x_m, x_e) = x.get_str(10, 0, rndn());
    assert(|_|"integer 123 exponent", x_e == 3);;
    
    // Test get_str with decimal number
    let y = MPFR::mpfr(113, 3.14159);
    let (y_m, y_e) = y.get_str(10, 10, rndn());
    assert(|_|"3.14159 mantissa with 10 digits", y_m == "3141590000");;
    assert(|_|"3.14159 exponent", y_e == 1);;
    
    // Test to_string (delegates to F64::to_string via get_f64)
    let z1 = MPFR::mpfr(113, 3.14159);
    assert(|_|"3.14159 formatted", z1.to_string == "3.141590");;
    
    pure()
);

test_string_formats : IO ();
test_string_formats = (
    // ==== to_string_exp tests ====

    // Test to_string_exp with pi (precision 113 bit)
    let pi = MPFR::const_pi(113);
    let pi_exp = pi.to_string_exp;
    assert(|_|"pi in exponential form starts with 3.1", pi_exp.starts_with("3.1"));;
    assert(|_|"pi in exponential form contains e", pi_exp.to_iter_bytes.check_any(|c| c == 'e'));;
    assert(|_|"pi exp ends with e+0", pi_exp.to_iter_bytes.check_any(|c| c == '+'));;

    // Test 1.0 (edge case: integer, exp=1, single digit)
    let one = MPFR::mpfr(113, 1.0);
    assert(|_|"1.0 in exp format", one.to_string_exp == "1.0e+0");;

    // Test 5.0 (another single-digit integer)
    let five = MPFR::mpfr(113, 5.0);
    assert(|_|"5.0 in exp format", five.to_string_exp == "5.0e+0");;

    // Test 10.0 (exp=2)
    let ten = MPFR::mpfr(113, 10.0);
    assert(|_|"10.0 in exp format", ten.to_string_exp == "1.0e+1");;

    // Test 100.0 (exp=3)
    let hundred = MPFR::mpfr(113, 100.0);
    assert(|_|"100.0 in exp format", hundred.to_string_exp == "1.0e+2");;

    // Test 123.0 (three-digit integer)
    let one_two_three = MPFR::mpfr(113, 123.0);
    assert(|_|"123.0 in exp format", one_two_three.to_string_exp == "1.23e+2");;

    // Test negative numbers
    let neg = MPFR::mpfr(113, -3.14159);
    let neg_exp = neg.to_string_exp;
    assert(|_|"negative exp starts with -3.1", neg_exp.starts_with("-3.1"));;

    // Test very large number
    let large = MPFR::mpfr(113, 1.23e100);
    let large_exp = large.to_string_exp;
    assert(|_|"large number exp starts with 1.23", large_exp.starts_with("1.23"));;
    assert(|_|"large number exp contains e+", large_exp.to_iter_bytes.check_any(|c| c == '+'));;

    // Test very small positive number (exp < 0): 0.1 = 1.000...e-1
    let pt1 = MPFR::mpfr(113, 0.1);
    let pt1_exp = pt1.to_string_exp;
    assert(|_|"0.1 exp starts with 1.", pt1_exp.starts_with("1."));;
    assert(|_|"0.1 exp ends with e-1", pt1_exp.to_iter_bytes.check_any(|c| c == '-'));;

    // Test very small number
    let small = MPFR::mpfr(113, 1.23e-100);
    let small_exp = small.to_string_exp;
    assert(|_|"small number exp starts with 1.23", small_exp.starts_with("1.23"));;
    assert(|_|"small number exp contains e-", small_exp.to_iter_bytes.check_any(|c| c == '-'));;

    // Test negative zero (should produce "-0.0e+0")
    let neg_zero = MPFR::mpfr(53, -0.0);
    assert(|_|"neg zero exp format", neg_zero.to_string_exp == "-0.0e+0");;

    // ==== to_string_exp_precision tests ====

    // Test basic case
    let x = MPFR::mpfr(113, 3.14159);
    let x_exp2 = x.to_string_exp_precision(2_I64);
    assert(|_|"3.14159 with exp precision 2", x_exp2 == "3.14e+0");;

    let y = MPFR::mpfr(113, 123.456);
    let y_exp3 = y.to_string_exp_precision(3_I64);
    assert(|_|"123.456 with exp precision 3", y_exp3 == "1.235e+2");;

    let z = MPFR::mpfr(113, 0.00123);
    let z_exp4 = z.to_string_exp_precision(4_I64);
    assert(|_|"0.00123 with exp precision 4 starts with 1.23", z_exp4.starts_with("1.23"));;

    // Test 1.0 (prec=3): "1.000e+0"
    assert(|_|"1.0 exp prec 3", one.to_string_exp_precision(3_I64) == "1.000e+0");;

    // Test 10.0 (prec=2): "1.00e+1"
    assert(|_|"10.0 exp prec 2", ten.to_string_exp_precision(2_I64) == "1.00e+1");;

    // Test 0.1 (prec=2): "1.00e-1"
    assert(|_|"0.1 exp prec 2", pt1.to_string_exp_precision(2_I64) == "1.00e-1");;

    // Test 0.01 (prec=2): "1.00e-2"
    let pt01 = MPFR::mpfr(113, 0.01);
    assert(|_|"0.01 exp prec 2", pt01.to_string_exp_precision(2_I64) == "1.00e-2");;

    // Test 1.5e-10 (prec=2): "1.50e-10"
    let small10 = MPFR::mpfr(113, 1.5e-10);
    assert(|_|"1.5e-10 exp prec 2", small10.to_string_exp_precision(2_I64) == "1.50e-10");;

    // Test negative numbers
    let neg_x = MPFR::mpfr(113, -3.14159);
    let neg_x_exp2 = neg_x.to_string_exp_precision(2_I64);
    assert(|_|"negative with exp precision 2", neg_x_exp2 == "-3.14e+0");;

    // Test precision 0 (integer part only)
    let p0 = MPFR::mpfr(113, 5.6789);
    let p0_exp = p0.to_string_exp_precision(0_I64);
    assert(|_|"exp precision 0 rounds to 6", p0_exp == "6.e+0");;

    // Test 1.0 prec=0: "1.e+0"
    assert(|_|"1.0 exp prec 0", one.to_string_exp_precision(0_I64) == "1.e+0");;

    // Test large exponent
    let large_e = MPFR::mpfr(113, 1.5e50);
    let large_e_str = large_e.to_string_exp_precision(2_I64);
    assert(|_|"1.5e50 exp prec 2 is 1.50e+50", large_e_str == "1.50e+50");;

    // Test negative exponent
    let small_e = MPFR::mpfr(113, 1.5e-50);
    let small_e_str = small_e.to_string_exp_precision(2_I64);
    assert(|_|"1.5e-50 exp prec 2 is 1.50e-50", small_e_str == "1.50e-50");;

    // Test 0.001 prec=3: "1.000e-3"
    let pt001 = MPFR::mpfr(113, 0.001);
    assert(|_|"0.001 exp prec 3", pt001.to_string_exp_precision(3_I64) == "1.000e-3");;

    // Test negative zero (prec=2): "-0.00e+0"
    assert(|_|"neg zero exp prec 2", neg_zero.to_string_exp_precision(2_I64) == "-0.00e+0");;

    // ==== to_string_precision tests ====

    // Test basic case
    let a = MPFR::mpfr(113, 3.14159);
    let a_prec2 = a.to_string_precision(2_I64);
    assert(|_|"3.14159 with precision 2", a_prec2 == "3.14");;

    let b = MPFR::mpfr_i(113, 42);
    let b_prec3 = b.to_string_precision(3_I64);
    assert(|_|"42 with precision 3", b_prec3 == "42.000");;

    let c = MPFR::mpfr(113, 0.5);
    let c_prec5 = c.to_string_precision(5_I64);
    assert(|_|"0.5 with precision 5", c_prec5 == "0.50000");;

    // Test 1.0 prec=3: "1.000"
    assert(|_|"1.0 prec 3", one.to_string_precision(3_I64) == "1.000");;

    // Test 10.0 prec=2: "10.00"
    assert(|_|"10.0 prec 2", ten.to_string_precision(2_I64) == "10.00");;

    // Test 100.0 prec=0: "100."
    assert(|_|"100.0 prec 0", hundred.to_string_precision(0_I64) == "100.");;

    // Test 123.0 prec=2: "123.00"
    assert(|_|"123.0 prec 2", one_two_three.to_string_precision(2_I64) == "123.00");;

    // Test 0.1 prec=2: "0.10"
    assert(|_|"0.1 prec 2", pt1.to_string_precision(2_I64) == "0.10");;

    // Test 0.01 prec=3: "0.010"
    assert(|_|"0.01 prec 3", pt01.to_string_precision(3_I64) == "0.010");;

    // Test 0.01 prec=1: "0.0" (too few digits to show the value)
    assert(|_|"0.01 prec 1", pt01.to_string_precision(1_I64) == "0.0");;

    // Test negative numbers
    let neg_a = MPFR::mpfr(113, -3.14159);
    let neg_a_prec2 = neg_a.to_string_precision(2_I64);
    assert(|_|"negative with precision 2", neg_a_prec2 == "-3.14");;

    // Test precision 0 (no fractional part)
    let prec0 = MPFR::mpfr(113, 3.7);
    let prec0_str = prec0.to_string_precision(0_I64);
    assert(|_|"3.7 precision 0 has trailing dot", prec0_str == "3." || prec0_str == "4.");;

    // Test 1.0 prec=0: "1."
    assert(|_|"1.0 prec 0", one.to_string_precision(0_I64) == "1.");;

    // Test 123.0 prec=0: "123."
    assert(|_|"123.0 prec 0", one_two_three.to_string_precision(0_I64) == "123.");;

    // Test very small number with limited precision
    let tiny = MPFR::mpfr(113, 0.000123);
    let tiny_prec2 = tiny.to_string_precision(2_I64);
    assert(|_|"tiny number precision 2", tiny_prec2 == "0.00");;

    let tiny_prec5 = tiny.to_string_precision(5_I64);
    assert(|_|"tiny number precision 5", tiny_prec5.starts_with("0.00012"));;

    // Test large integer
    let big_int = MPFR::mpfr_i(113, 9999);
    let big_int_prec2 = big_int.to_string_precision(2_I64);
    assert(|_|"large int with precision 2", big_int_prec2 == "9999.00");;

    // Test number requiring padding
    let pad = MPFR::mpfr(113, 7.0);
    let pad_prec4 = pad.to_string_precision(4_I64);
    assert(|_|"7.0 with precision 4", pad_prec4 == "7.0000");;

    // Test decimal point in middle (12.34 in MPFR with prec 3)
    let mid = MPFR::mpfr(113, 12.34);
    let mid_prec3 = mid.to_string_precision(3_I64);
    assert(|_|"12.34 with precision 3", mid_prec3 == "12.339");;

    // Test negative zero prec=2: "-0.00"
    assert(|_|"neg zero prec 2", neg_zero.to_string_precision(2_I64) == "-0.00");;

    // ==== Special values tests ====

    let nan_val = MPFR::nan(53);
    assert(|_|"nan exp format", nan_val.to_string_exp == "@NaN@");;
    assert(|_|"nan exp precision format", nan_val.to_string_exp_precision(2_I64) == "@NaN@");;
    assert(|_|"nan precision format", nan_val.to_string_precision(2_I64) == "@NaN@");;
    assert(|_|"nan exp digits format", nan_val.to_string_exp_digits(2_I64) == "@NaN@");;
    assert(|_|"nan digits format", nan_val.to_string_digits(2_I64) == "@NaN@");;

    let inf_val = MPFR::inf(53);
    assert(|_|"inf exp format", inf_val.to_string_exp == "@Inf@");;
    assert(|_|"inf exp precision format", inf_val.to_string_exp_precision(2_I64) == "@Inf@");;
    assert(|_|"inf precision format", inf_val.to_string_precision(2_I64) == "@Inf@");;
    assert(|_|"inf exp digits format", inf_val.to_string_exp_digits(2_I64) == "@Inf@");;
    assert(|_|"inf digits format", inf_val.to_string_digits(2_I64) == "@Inf@");;

    let neg_inf_val = MPFR::neg_inf(53);
    assert(|_|"neg_inf exp format", neg_inf_val.to_string_exp == "-@Inf@");;
    assert(|_|"neg_inf exp precision format", neg_inf_val.to_string_exp_precision(2_I64) == "-@Inf@");;
    assert(|_|"neg_inf precision format", neg_inf_val.to_string_precision(2_I64) == "-@Inf@");;
    assert(|_|"neg_inf exp digits format", neg_inf_val.to_string_exp_digits(2_I64) == "-@Inf@");;
    assert(|_|"neg_inf digits format", neg_inf_val.to_string_digits(2_I64) == "-@Inf@");;

    let zero = MPFR::zero(53);
    assert(|_|"zero exp format", zero.to_string_exp == "0.0e+0");;
    assert(|_|"zero exp precision 3", zero.to_string_exp_precision(3_I64) == "0.000e+0");;
    assert(|_|"zero exp precision 1", zero.to_string_exp_precision(1_I64) == "0.0e+0");;
    assert(|_|"zero precision 4", zero.to_string_precision(4_I64) == "0.0000");;
    assert(|_|"zero precision 0", zero.to_string_precision(0_I64) == "0.");;
    assert(|_|"zero digits 1", zero.to_string_digits(1_I64) == "0");;

    // ==== to_string_exp_digits tests ====

    // Test basic case
    let d1 = MPFR::mpfr(113, 3.14159);
    let d1_exp3 = d1.to_string_exp_digits(3_I64);
    assert(|_|"3.14159 with exp digits 3", d1_exp3 == "3.14e+0");;

    let d2 = MPFR::mpfr(113, 314.159);
    let d2_exp3 = d2.to_string_exp_digits(3_I64);
    assert(|_|"314.159 with exp digits 3", d2_exp3 == "3.14e+2");;

    let d3 = MPFR::mpfr(113, 0.00314159);
    let d3_exp4 = d3.to_string_exp_digits(4_I64);
    assert(|_|"0.00314159 with exp digits 4", d3_exp4 == "3.142e-3");;

    // Test 1.0 (digits=3): "1.00e+0"
    assert(|_|"1.0 exp digits 3", one.to_string_exp_digits(3_I64) == "1.00e+0");;

    // Test 10.0 (digits=2): "1.0e+1"
    assert(|_|"10.0 exp digits 2", ten.to_string_exp_digits(2_I64) == "1.0e+1");;

    // Test 0.1 (digits=2): "1.0e-1"
    assert(|_|"0.1 exp digits 2", pt1.to_string_exp_digits(2_I64) == "1.0e-1");;

    // Test 0.01 (digits=3): "1.00e-2"
    assert(|_|"0.01 exp digits 3 is 1.00e-2", pt01.to_string_exp_digits(3_I64) == "1.00e-2");;

    // Test 1.5e-10 (digits=3): "1.50e-10"
    assert(|_|"1.5e-10 exp digits 3", small10.to_string_exp_digits(3_I64) == "1.50e-10");;

    // Test negative numbers
    let d4 = MPFR::mpfr(113, -123.456);
    let d4_exp2 = d4.to_string_exp_digits(2_I64);
    assert(|_|"negative with exp digits 2", d4_exp2 == "-1.2e+2");;

    // Test 1 digit: 5.0 → "5.e+0"
    let d5 = MPFR::mpfr(113, 5.0);
    assert(|_|"5.0 exp digits 1", d5.to_string_exp_digits(1_I64) == "5.e+0");;

    // Test 1 digit with rounding: 567.89 → "6.e+2" (rounds up) or "5.e+2"
    let d5b = MPFR::mpfr(113, 567.89);
    let d5b_exp1 = d5b.to_string_exp_digits(1_I64);
    assert(|_|"567.89 exp digits 1", d5b_exp1 == "5.e+2" || d5b_exp1 == "6.e+2");;

    // Test large exponent
    let d6 = MPFR::mpfr(113, 1.23e50);
    let d6_exp5 = d6.to_string_exp_digits(5_I64);
    assert(|_|"1.23e50 exp digits 5 contains e+", d6_exp5.to_iter_bytes.check_any(|c| c == '+'));;
    assert(|_|"1.23e50 exp digits 5 starts with 1.23", d6_exp5.starts_with("1.23"));;

    // Test zero with digits
    let zero_d = MPFR::zero(53);
    assert(|_|"zero exp digits 3", zero_d.to_string_exp_digits(3_I64) == "0.00e+0");;
    assert(|_|"zero exp digits 1", zero_d.to_string_exp_digits(1_I64) == "0.e+0");;
    assert(|_|"zero exp digits 2", zero_d.to_string_exp_digits(2_I64) == "0.0e+0");;

    // Test negative zero (digits=2): "-0.0e+0"
    assert(|_|"neg zero exp digits 2", neg_zero.to_string_exp_digits(2_I64) == "-0.0e+0");;

    // Test special values with exp_digits
    assert(|_|"nan exp digits", nan_val.to_string_exp_digits(3_I64) == "@NaN@");;
    assert(|_|"inf exp digits", inf_val.to_string_exp_digits(3_I64) == "@Inf@");;
    assert(|_|"neg_inf exp digits", neg_inf_val.to_string_exp_digits(3_I64) == "-@Inf@");;

    // ==== to_string_digits tests ====

    // Test basic case
    let e1 = MPFR::mpfr(113, 3.14159);
    let e1_dig3 = e1.to_string_digits(3_I64);
    assert(|_|"3.14159 with digits 3", e1_dig3 == "3.14");;

    let e2 = MPFR::mpfr(113, 314.159);
    let e2_dig3 = e2.to_string_digits(3_I64);
    assert(|_|"314.159 with digits 3", e2_dig3 == "314");;

    let e3 = MPFR::mpfr(113, 0.00314159);
    let e3_dig3 = e3.to_string_digits(3_I64);
    assert(|_|"0.00314159 with digits 3", e3_dig3 == "0.00314");;

    // Test 1.0 (digits=3): "1.00"
    assert(|_|"1.0 digits 3", one.to_string_digits(3_I64) == "1.00");;

    // Test 1.0 (digits=1): "1"
    assert(|_|"1.0 digits 1", one.to_string_digits(1_I64) == "1");;

    // Test 10.0 (digits=3): "10.0"
    assert(|_|"10.0 digits 3", ten.to_string_digits(3_I64) == "10.0");;

    // Test 100.0 (digits=2): "100"
    assert(|_|"100.0 digits 2", hundred.to_string_digits(2_I64) == "100");;

    // Test 100.0 (digits=3): "100"
    assert(|_|"100.0 digits 3", hundred.to_string_digits(3_I64) == "100");;

    // Test 0.1 (digits=2): "0.10"
    assert(|_|"0.1 digits 2", pt1.to_string_digits(2_I64) == "0.10");;

    // Test 0.01 (digits=3): "0.0100"
    assert(|_|"0.01 digits 3", pt01.to_string_digits(3_I64) == "0.0100");;

    // Test negative numbers
    let e4 = MPFR::mpfr(113, -123.456);
    let e4_dig4 = e4.to_string_digits(4_I64);
    assert(|_|"negative with digits 4", e4_dig4 == "-123.5");;

    // Test 5.0 with 1 digit: "5"
    assert(|_|"5.0 digits 1", d5.to_string_digits(1_I64) == "5");;

    // Test 1 digit with rounding
    let e5 = MPFR::mpfr(113, 5.678);
    let e5_dig1 = e5.to_string_digits(1_I64);
    assert(|_|"5.678 digits 1", e5_dig1 == "5" || e5_dig1 == "6");;

    // Test large number (5 digits, rounds last digit)
    let e6 = MPFR::mpfr(113, 123456.789);
    let e6_dig5 = e6.to_string_digits(5_I64);
    assert(|_|"123456.789 with digits 5", e6_dig5 == "123460");;

    // Test small number
    let e7 = MPFR::mpfr(113, 0.000123456);
    let e7_dig5 = e7.to_string_digits(5_I64);
    assert(|_|"0.000123456 with digits 5", e7_dig5.starts_with("0.00012"));;

    // Test integer with fewer digits than integer length (rounds with trailing zeros)
    let e8 = MPFR::mpfr_i(113, 123);
    let e8_dig2 = e8.to_string_digits(2_I64);
    assert(|_|"123 with digits 2", e8_dig2 == "120");;

    // Test 9999 with digits=2: rounds up to 10000
    let nine999 = MPFR::mpfr_i(113, 9999);
    assert(|_|"9999 with digits 2", nine999.to_string_digits(2_I64) == "10000");;

    // Test 9999 with digits=4: "9999"
    assert(|_|"9999 with digits 4", nine999.to_string_digits(4_I64) == "9999");;

    // Test 123.0 with digits=5: "123.00"
    assert(|_|"123.0 digits 5", one_two_three.to_string_digits(5_I64) == "123.00");;

    // Test zero with digits
    let zero_e = MPFR::zero(53);
    assert(|_|"zero digits 3", zero_e.to_string_digits(3_I64) == "0");;
    assert(|_|"zero digits 1", zero_e.to_string_digits(1_I64) == "0");;

    // Test negative zero digits=2: "-0"
    assert(|_|"neg zero digits 2", neg_zero.to_string_digits(2_I64) == "-0");;

    // Test special values with digits
    assert(|_|"nan digits", nan_val.to_string_digits(3_I64) == "@NaN@");;
    assert(|_|"inf digits", inf_val.to_string_digits(3_I64) == "@Inf@");;
    assert(|_|"neg_inf digits", neg_inf_val.to_string_digits(3_I64) == "-@Inf@");;

    pure()
);

test_power_root : IO ();
test_power_root = (
    // Test sqr
    let x = MPFR::mpfr_i(113, 5);
    let x2 = x.sqr;
    assert_eq(|_|"sqr(5)", x2.get_si.as_some, 25);;

    // Test sqrt
    let y = MPFR::mpfr_i(113, 25);
    let y_sqrt = y.sqrt;
    assert_eq(|_|"sqrt(25)", y_sqrt.get_si.as_some, 5);;

    // Test cbrt
    let z = MPFR::mpfr_i(113, 27);
    let z_cbrt = z.cbrt;
    assert_eq(|_|"cbrt(27)", z_cbrt.get_si.as_some, 3);;

    // Test rootn_ui
    let w = MPFR::mpfr_i(113, 16);
    let w_root4 = MPFR::rootn_ui(4_U64, w);
    assert_eq(|_|"rootn_ui(4, 16)", w_root4.get_si.as_some, 2);;

    // Test pow
    let base = MPFR::mpfr_i(113, 2);
    let exp = MPFR::mpfr_i(113, 10);
    let result = MPFR::pow(base, exp);
    assert_eq(|_|"pow(2, 10)", result.get_si.as_some, 1024);;

    // Test pow_ui
    let base2 = MPFR::mpfr_i(113, 3);
    let result2 = MPFR::pow_ui(4_U64, base2);
    assert_eq(|_|"pow_ui(4, 3)", result2.get_si.as_some, 81);;

    // Test mul_2ui (multiply by 2^n)
    let a = MPFR::mpfr_i(113, 5);
    let a_shifted = MPFR::mul_2ui(3_U64, a);
    assert_eq(|_|"mul_2ui(3, 5)", a_shifted.get_si.as_some, 40);;

    pure()
);

test_exponential_logarithm : IO ();
test_exponential_logarithm = (
    // Test exp and log
    let x = MPFR::mpfr(113, 2.0);
    let exp_x = x.exp;
    let log_exp_x = exp_x.log;
    let diff = MPFR::abs(MPFR::sub(log_exp_x, x));
    assert(|_|"log(exp(x)) == x", diff.get_f64 < 0.000001);;

    // Test log2
    let eight = MPFR::mpfr_i(113, 8);
    let log2_8 = eight.log2;
    assert_eq(|_|"log2(8)", log2_8.get_si.as_some, 3);;

    // Test log10
    let thousand = MPFR::mpfr_i(113, 1000);
    let log10_1000 = thousand.log10;
    assert_eq(|_|"log10(1000)", log10_1000.get_si.as_some, 3);;

    pure()
);

test_trigonometric : IO ();
test_trigonometric = (
    let pi = MPFR::const_pi(113);
    
    // Test sin(pi/2) == 1
    let pi_2 = MPFR::div(pi, MPFR::mpfr_i(113, 2));
    let sin_pi_2 = pi_2.sin;
    let diff1 = MPFR::abs(MPFR::sub(sin_pi_2, MPFR::mpfr(113, 1.0)));
    assert(|_|"sin(pi/2) == 1", diff1.get_f64 < 0.000001);;

    // Test cos(0) == 1
    let zero = MPFR::mpfr_i(113, 0);
    let cos_0 = zero.cos;
    assert_eq(|_|"cos(0)", cos_0.get_si.as_some, 1);;

    // Test asin(1) ~= pi/2
    let one = MPFR::mpfr_i(113, 1);
    let asin_1 = one.asin;
    let diff2 = MPFR::abs(MPFR::sub(asin_1, pi_2));
    assert(|_|"asin(1) == pi/2", diff2.get_f64 < 0.000001);;

    // Test atan2
    let y = MPFR::mpfr_i(113, 1);
    let x = MPFR::mpfr_i(113, 1);
    let atan2_result = MPFR::atan2(y, x);
    let pi_4 = MPFR::div(pi, MPFR::mpfr_i(113, 4));
    let diff3 = MPFR::abs(MPFR::sub(atan2_result, pi_4));
    assert(|_|"atan2(1,1) == pi/4", diff3.get_f64 < 0.000001);;

    pure()
);

test_constants : IO ();
test_constants = (
    // Test const_pi
    let pi = MPFR::const_pi(113);
    let pi_f64 = pi.get_f64;
    assert(|_|"pi ~= 3.14159", (pi_f64 - 3.14159265358979).abs < 0.00001);;

    // Test const_log2
    let log2 = MPFR::const_log2(113);
    let log2_f64 = log2.get_f64;
    assert(|_|"log2 ~= 0.693", (log2_f64 - 0.69314718055995).abs < 0.00001);;

    // Test const_euler
    let euler = MPFR::const_euler(113);
    let euler_f64 = euler.get_f64;
    assert(|_|"euler ~= 0.577", (euler_f64 - 0.57721566490153).abs < 0.00001);;

    pure()
);

test_hyperbolic : IO ();
test_hyperbolic = (
    let zero = MPFR::mpfr_i(113, 0);
    
    // Test sinh(0) == 0
    let sinh_0 = zero.sinh;
    assert(|_|"sinh(0) == 0", sinh_0.is_zero);;

    // Test cosh(0) == 1
    let cosh_0 = zero.cosh;
    assert_eq(|_|"cosh(0)", cosh_0.get_si.as_some, 1);;

    // Test tanh identity: tanh(x) == sinh(x)/cosh(x)
    let x = MPFR::mpfr(113, 0.5);
    let tanh_x = x.tanh;
    let sinh_x = x.sinh;
    let cosh_x = x.cosh;
    let manual_tanh = MPFR::div(sinh_x, cosh_x);
    let diff = MPFR::abs(MPFR::sub(tanh_x, manual_tanh));
    assert(|_|"tanh(x) == sinh(x)/cosh(x)", diff.get_f64 < 0.000001);;

    // Test asinh(sinh(x)) ~= x
    let y = MPFR::mpfr(113, 1.0);
    let sinh_y = y.sinh;
    let asinh_sinh_y = sinh_y.asinh;
    let diff2 = MPFR::abs(MPFR::sub(asinh_sinh_y, y));
    assert(|_|"asinh(sinh(x)) == x", diff2.get_f64 < 0.000001);;

    pure()
);

test_special_functions : IO ();
test_special_functions = (
    // Test gamma(1) == 1
    let one = MPFR::mpfr_i(113, 1);
    let gamma_1 = one.gamma;
    assert_eq(|_|"gamma(1)", gamma_1.get_si.as_some, 1);;

    // Test gamma(5) == 24 (4!)
    let five = MPFR::mpfr_i(113, 5);
    let gamma_5 = five.gamma;
    assert_eq(|_|"gamma(5) == 24", gamma_5.get_si.as_some, 24);;

    // Test lngamma(1) == 0
    let lngamma_1 = one.lngamma;
    assert(|_|"lngamma(1) == 0", lngamma_1.is_zero);;

    // Test erf(0) == 0
    let zero = MPFR::mpfr_i(113, 0);
    let erf_0 = zero.erf;
    assert(|_|"erf(0) == 0", erf_0.is_zero);;

    // Test erfc(0) == 1
    let erfc_0 = zero.erfc;
    assert_eq(|_|"erfc(0) == 1", erfc_0.get_si.as_some, 1);;

    // Test erf(x) + erfc(x) == 1
    let x = MPFR::mpfr(113, 0.5);
    let erf_x = x.erf;
    let erfc_x = x.erfc;
    let sum = MPFR::add(erf_x, erfc_x);
    let diff = MPFR::abs(MPFR::sub(sum, MPFR::mpfr_i(113, 1)));
    assert(|_|"erf(x) + erfc(x) == 1", diff.get_f64 < 0.000001);;

    pure()
);

test_bit_shift_division : IO ();
test_bit_shift_division = (
    let x = MPFR::mpfr_i(113, 64);
    
    // Test div_2ui: 64 / 2^3 = 8
    let result = MPFR::div_2ui(3_U64, x);
    assert_eq(|_|"64 / 2^3", result.get_si.as_some, 8);;
    
    // Test div_2si: 64 / 2^2 = 16
    let result2 = MPFR::div_2si(2, x);
    assert_eq(|_|"64 / 2^2", result2.get_si.as_some, 16);;
    
    // Test div_2si with negative (multiply): 64 / 2^(-1) = 128
    let result3 = MPFR::div_2si(-1, x);
    assert_eq(|_|"64 / 2^(-1)", result3.get_si.as_some, 128);;
    
    pure()
);

test_exponential_extended : IO ();
test_exponential_extended = (
    // Test exp2: 2^3 = 8
    let x = MPFR::mpfr_i(113, 3);
    let result = x.exp2;
    assert_eq(|_|"2^3", result.get_si.as_some, 8);;
    
    // Test exp10: 10^2 = 100
    let y = MPFR::mpfr_i(113, 2);
    let result2 = y.exp10;
    assert_eq(|_|"10^2", result2.get_si.as_some, 100);;
    
    // Test expm1: expm1(0) = 0
    let zero = MPFR::mpfr_i(113, 0);
    let result3 = zero.expm1;
    assert(|_|"expm1(0)", result3.is_zero);;
    
    // Test log1p: log1p(0) = 0
    let result4 = zero.log1p;
    assert(|_|"log1p(0)", result4.is_zero);;
    
    pure()
);

test_integer_functions : IO ();
test_integer_functions = (
    let x = MPFR::mpfr(113, 3.7);
    
    // Test ceil: ceil(3.7) = 4
    let c = x.ceil;
    assert_eq(|_|"ceil(3.7)", c.get_si.as_some, 4);;
    
    // Test floor: floor(3.7) = 3
    let f = x.floor;
    assert_eq(|_|"floor(3.7)", f.get_si.as_some, 3);;
    
    // Test round: round(3.7) = 4
    let r = x.round;
    assert_eq(|_|"round(3.7)", r.get_si.as_some, 4);;
    
    // Test trunc: trunc(3.7) = 3
    let t = x.trunc;
    assert_eq(|_|"trunc(3.7)", t.get_si.as_some, 3);;
    
    // Test with negative number
    let y = MPFR::mpfr(113, -2.3);
    let c2 = y.ceil;
    assert_eq(|_|"ceil(-2.3)", c2.get_si.as_some, -2);;
    
    let f2 = y.floor;
    assert_eq(|_|"floor(-2.3)", f2.get_si.as_some, -3);;
    
    pure()
);

test_minmax : IO ();
test_minmax = (
    let x = MPFR::mpfr_i(113, 5);
    let y = MPFR::mpfr_i(113, 3);
    
    // Test min
    let min_val = MPFR::min(x, y);
    assert_eq(|_|"min(5, 3)", min_val.get_si.as_some, 3);;
    
    // Test max
    let max_val = MPFR::max(x, y);
    assert_eq(|_|"max(5, 3)", max_val.get_si.as_some, 5);;
    
    pure()
);

test_advanced_math : IO ();
test_advanced_math = (
    // Test fma: 2*3 + 4 = 10
    let x = MPFR::mpfr_i(113, 2);
    let y = MPFR::mpfr_i(113, 3);
    let z = MPFR::mpfr_i(113, 4);
    let result = MPFR::fma(x, y, z);
    assert_eq(|_|"2*3 + 4", result.get_si.as_some, 10);;
    
    // Test hypot: hypot(3, 4) = 5
    let a = MPFR::mpfr_i(113, 3);
    let b = MPFR::mpfr_i(113, 4);
    let h = MPFR::hypot(a, b);
    assert_eq(|_|"hypot(3, 4)", h.get_si.as_some, 5);;
    
    // Test fac_ui: 5! = 120
    let fac5 = MPFR::fac_ui(5_U64, 113);
    assert_eq(|_|"5!", fac5.get_si.as_some, 120);;
    
    // Test fmod: fmod(7, 3) = 1
    let p = MPFR::mpfr_i(113, 7);
    let q = MPFR::mpfr_i(113, 3);
    let fm = MPFR::fmod(p, q);
    assert_eq(|_|"fmod(7, 3)", fm.get_si.as_some, 1);;
    
    pure()
);

test_additional_trig : IO ();
test_additional_trig = (
    let zero = MPFR::mpfr_i(113, 0);
    
    // Test sec(0) = 1
    let sec_0 = zero.sec;
    assert_eq(|_|"sec(0)", sec_0.get_si.as_some, 1);;
    
    // Test sech(0) = 1
    let sech_0 = zero.sech;
    assert_eq(|_|"sech(0)", sech_0.get_si.as_some, 1);;
    
    pure()
);

test_zeta_beta : IO ();
test_zeta_beta = (
    // Test zeta_ui(2) ~= pi^2/6 ~= 1.6449
    let zeta_2 = MPFR::zeta_ui(2_U64, 113);
    let val = zeta_2.get_f64;
    assert(|_|"zeta(2) ~= 1.6449", (val - 1.6449).abs < 0.001);;
    
    // Test digamma(1) ~= -0.5772 (negative Euler constant)
    let one = MPFR::mpfr(113, 1.0);
    let dig1 = one.digamma;
    let val2 = dig1.get_f64;
    assert(|_|"digamma(1) ~= -0.5772", (val2 + 0.5772).abs < 0.001);;
    
    pure()
);

test_bessel : IO ();
test_bessel = (
    // Test j0(0) = 1
    let zero = MPFR::mpfr(113, 0.0);
    let j0_0 = zero.j0;
    assert_eq(|_|"j0(0)", j0_0.get_si.as_some, 1);;
    
    // Test j1(0) = 0
    let j1_0 = zero.j1;
    assert(|_|"j1(0)", j1_0.is_zero);;
    
    pure()
);

test_utilities : IO ();
test_utilities = (
    // Test signbit
    let pos = MPFR::mpfr(113, 5.0);
    let neg = MPFR::mpfr(113, -5.0);
    assert_eq(|_|"signbit(5)", pos.signbit, false);;
    assert_eq(|_|"signbit(-5)", neg.signbit, true);;
    
    // Test copysign: copysign(5, -3) = -5
    let x = MPFR::mpfr(113, 5.0);
    let y = MPFR::mpfr(113, -3.0);
    let result = MPFR::copysign(x, y);
    assert_eq(|_|"copysign(5, -3)", result.get_si.as_some, -5);;
    
    // Test const_catalan
    let catalan = MPFR::const_catalan(113);
    let val = catalan.get_f64;
    assert(|_|"Catalan constant ~= 0.9159", (val - 0.9159).abs < 0.001);;
    
    pure()
);

test : IO ();
test = (
    test_basic_construction;;
    test_arithmetic;;
    test_comparison;;
    test_conversion;;
    test_special_values;;
    test_precision;;
    test_string_conversion;;
    test_string_output;;
    test_string_formats;;
    test_power_root;;
    test_exponential_logarithm;;
    test_trigonometric;;
    test_constants;;
    test_hyperbolic;;
    test_special_functions;;
    test_bit_shift_division;;
    test_exponential_extended;;
    test_integer_functions;;
    test_minmax;;
    test_advanced_math;;
    test_additional_trig;;
    test_zeta_beta;;
    test_bessel;;
    test_utilities;;

    pure()
);

main : IO ();
main = test;
