// Tests for MPFR module
module Test;

import MPFR::MPFR::{
    abs, add, asin, asinh, atan2, cbrt, ceil, cmp, const_catalan, const_euler, const_log2, const_pi, 
    copysign, cos, cosh, digamma, div, div_2si, div_2ui, erf, erfc, exp, exp10, exp2, expm1, fac_ui, 
    floor, fma, fmod, gamma, get_f64, get_prec, get_si, get_str, get_str_ndigits, get_ui, hypot, inf, 
    is_inf, is_nan, is_number, is_zero, j0, j1, lngamma, log, log10, log1p, log2, max, min, mpfr, mpfr_i, 
    mpfr_str, mpfr_ui, mul_2ui, nan, neg_inf, pow, pow_ui, rootn_ui, round, sec, sech, sgn, signbit, sin, 
    sinh, sqr, sqrt, sub, tanh, to_string_exp, to_string_exp_precision, to_string_precision, trunc, zero, zeta_ui
};
import MPFR::RoundMode::{rndn};
import Std::{F64, IO, U8, Array::{pop_back, to_iter}, Debug::{assert, assert_eq}, F64::abs, IO::println, Iterator::check_any, Monad::pure, Option::{as_some, is_none, is_some}, String::{get_bytes, starts_with, to_iter_bytes}, ToString::to_string};

test_basic_construction : IO ();
test_basic_construction = (
    // Test mpfr from I64
    let x = MPFR::mpfr_i(53, 42);
    assert_eq(|_|"mpfr from I64", x.get_si.as_some, 42);;

    // Test mpfr from U64
    let y = MPFR::mpfr_ui(53, 100_U64);
    assert_eq(|_|"mpfr from U64", y.get_ui.as_some, 100_U64);;

    // Test mpfr from F64
    let z = MPFR::mpfr(113, 3.14159);
    let z_f64 = z.get_f64;
    assert(|_|"mpfr from F64", (z_f64 - 3.14159).abs < 0.00001);;

    // Test special values
    let zero_val = MPFR::zero(53);
    assert(|_|"zero is_zero", zero_val.is_zero);;
    
    let nan_val = MPFR::nan(53);
    assert(|_|"nan is_nan", nan_val.is_nan);;
    
    let inf_val = MPFR::inf(53);
    assert(|_|"inf is_inf", inf_val.is_inf);;
    
    let neg_inf_val = MPFR::neg_inf(53);
    assert(|_|"neg_inf is_inf", neg_inf_val.is_inf);;
    assert_eq(|_|"neg_inf sgn", neg_inf_val.sgn, -1);;

    pure()
);

test_arithmetic : IO ();
test_arithmetic = (
    let x = MPFR::mpfr_i(113, 10);
    let y = MPFR::mpfr_i(113, 3);

    // Test addition
    let sum = x + y;
    assert_eq(|_|"10 + 3", sum.get_si.as_some, 13);;

    // Test subtraction
    let diff = x - y;
    assert_eq(|_|"10 - 3", diff.get_si.as_some, 7);;

    // Test multiplication
    let prod = x * y;
    assert_eq(|_|"10 * 3", prod.get_si.as_some, 30);;

    // Test division
    let quot = x / y;
    let quot_f64 = quot.get_f64;
    assert(|_|"10 / 3", (quot_f64 - 3.333333).abs < 0.00001);;

    // Test negation
    let neg_x = -x;
    assert_eq(|_|"negation", neg_x.get_si.as_some, -10);;

    // Test absolute value
    let abs_neg = MPFR::abs(neg_x);
    assert_eq(|_|"abs(-10)", abs_neg.get_si.as_some, 10);;

    pure()
);

test_comparison : IO ();
test_comparison = (
    let x = MPFR::mpfr_i(53, 10);
    let y = MPFR::mpfr_i(53, 20);
    let z = MPFR::mpfr_i(53, 10);

    // Test equality
    assert(|_|"x == z", x == z);;
    assert(|_|"x != y", !(x == y));;

    // Test less than
    assert(|_|"x < y", x < y);;
    assert(|_|"!(y < x)", !(y < x));;

    // Test less than or equal
    assert(|_|"x <= z", x <= z);;
    assert(|_|"x <= y", x <= y);;

    // Test cmp - use MPFR::cmp(lhs, rhs) not x.cmp(y)
    assert_eq(|_|"cmp x z", MPFR::cmp(x, z), 0);;
    assert(|_|"cmp x y < 0", MPFR::cmp(x, y) < 0);;
    assert(|_|"cmp y x > 0", MPFR::cmp(y, x) > 0);;

    pure()
);

test_conversion : IO ();
test_conversion = (
    // Test I64 conversion
    let x = MPFR::mpfr_i(53, 12345);
    assert_eq(|_|"MPFR to I64", x.get_si.as_some, 12345);;

    // Test U64 conversion
    let y = MPFR::mpfr_ui(53, 67890_U64);
    assert_eq(|_|"MPFR to U64", y.get_ui.as_some, 67890_U64);;

    // Test F64 conversion
    let z = MPFR::mpfr(113, 2.718281828);
    let z_f64 = z.get_f64;
    assert(|_|"MPFR to F64", (z_f64 - 2.718281828).abs < 0.00000001);;

    pure()
);

test_special_values : IO ();
test_special_values = (
    let normal = MPFR::mpfr_i(53, 42);
    let nan_val = MPFR::nan(53);
    let inf_val = MPFR::inf(53);
    let zero_val = MPFR::zero(53);

    // Test predicates on normal value
    assert(|_|"normal.is_number", normal.is_number);;
    assert(|_|"!normal.is_nan", !normal.is_nan);;
    assert(|_|"!normal.is_inf", !normal.is_inf);;
    assert(|_|"!normal.is_zero", !normal.is_zero);;

    // Test predicates on special values
    assert(|_|"nan.is_nan", nan_val.is_nan);;
    assert(|_|"inf.is_inf", inf_val.is_inf);;
    assert(|_|"zero.is_zero", zero_val.is_zero);;

    // Test sign
    let pos = MPFR::mpfr_i(53, 10);
    let neg = MPFR::mpfr_i(53, -10);
    assert(|_|"sgn(10) > 0", pos.sgn > 0);;
    assert(|_|"sgn(-10) < 0", neg.sgn < 0);;
    assert_eq(|_|"sgn(0)", zero_val.sgn, 0);;

    pure()
);

test_precision : IO ();
test_precision = (
    let x53 = MPFR::mpfr_i(53, 1);
    let x113 = MPFR::mpfr_i(113, 1);
    let x256 = MPFR::mpfr_i(256, 1);

    assert_eq(|_|"precision 53", x53.get_prec, 53);;
    assert_eq(|_|"precision 113", x113.get_prec, 113);;
    assert_eq(|_|"precision 256", x256.get_prec, 256);;

    // Test that operations preserve maximum precision
    let sum = x53 + x113;
    assert_eq(|_|"precision after add", sum.get_prec, 113);;

    pure()
);

test_string_conversion : IO ();
test_string_conversion = (
    // Test mpfr_str
    let from_str = MPFR::mpfr_str(113, "123.456", 10);
    assert(|_|"from_str success", from_str.is_some);;
    let val = from_str.as_some;
    let val_f64 = val.get_f64;
    assert(|_|"from_str value", (val_f64 - 123.456).abs < 0.001);;

    // Test hex string
    let from_hex = MPFR::mpfr_str(113, "1A.5", 16);
    assert(|_|"from_hex success", from_hex.is_some);;
    let hex_val = from_hex.as_some;
    let hex_f64 = hex_val.get_f64;
    assert(|_|"from_hex value", (hex_f64 - 26.3125).abs < 0.001);;

    // Test invalid string
    let invalid = MPFR::mpfr_str(113, "invalid", 10);
    assert(|_|"invalid string fails", invalid.is_none);;

    pure()
);

test_string_output : IO ();
test_string_output = (
    // Test get_str_ndigits
    let ndigits = MPFR::get_str_ndigits(10, 113);
    assert(|_|"get_str_ndigits(10, 113) returns expected value", ndigits == 36);;
    
    // Test get_str with pi
    let pi = MPFR::const_pi(113);
    let (pi_mantissa, pi_exp) = pi.get_str(10, 10, rndn());
    assert(|_|"pi mantissa with 10 digits", pi_mantissa == "3141592654");;
    assert(|_|"pi exponent", pi_exp == 1);;
    
    // Test get_str with a simple integer
    let x = MPFR::mpfr_i(113, 123);
    let (x_m, x_e) = x.get_str(10, 0, rndn());
    assert(|_|"integer 123 exponent", x_e == 3);;
    
    // Test get_str with decimal number
    let y = MPFR::mpfr(113, 3.14159);
    let (y_m, y_e) = y.get_str(10, 10, rndn());
    assert(|_|"3.14159 mantissa with 10 digits", y_m == "3141590000");;
    assert(|_|"3.14159 exponent", y_e == 1);;
    
    // Test to_string with specific values (shows full precision)
    let z1 = MPFR::mpfr(113, 3.14159);
    let z1_str = z1.to_string;
    assert(|_|"3.14159 formatted", z1_str == "3.14158999999999988261834005243144929");;
    
    // Test integer formatting
    let z2 = MPFR::mpfr_i(113, 42);
    let z2_str = z2.to_string;
    assert(|_|"integer 42 formatted", z2_str == "42");;
    
    // Test large number
    let z3 = MPFR::mpfr_i(113, 12345);
    let z3_str = z3.to_string;
    assert(|_|"integer 12345 formatted", z3_str == "12345");;
    
    // Test small number
    let z4 = MPFR::mpfr(113, 0.001);
    let z4_str = z4.to_string;
    assert(|_|"0.001 formatted", z4_str == "0.00100000000000000002081668171172168513");;
    
    // Test with zero
    let zero = MPFR::zero(53);
    let zero_str = zero.to_string;
    assert(|_|"zero formatted", zero_str == "0");;
    
    // Test ToString trait
    let w = MPFR::mpfr(113, 2.718281828);
    let w_str = w.to_string;
    assert(|_|"e formatted with default precision", w_str == "2.71828182799999984453620527347084135");;
    
    // Test special values with to_string
    let nan_val = MPFR::nan(53);
    let nan_str = nan_val.to_string;
    assert(|_|"nan formatted", nan_str == "@NaN@");;
    
    let inf_val = MPFR::inf(53);
    let inf_str = inf_val.to_string;
    assert(|_|"inf formatted", inf_str == "@Inf@");;
    
    let neg_inf_val = MPFR::neg_inf(53);
    let neg_inf_str = neg_inf_val.to_string;
    assert(|_|"neg_inf formatted", neg_inf_str == "-@Inf@");;
    
    pure()
);

test_string_formats : IO ();
test_string_formats = (
    // ==== to_string_exp tests ====
    
    // Test to_string_exp with pi
    let pi = MPFR::const_pi(113);
    let pi_exp = pi.to_string_exp;
    assert(|_|"pi in exponential form starts with 3.1", pi_exp.starts_with("3.1"));;
    assert(|_|"pi in exponential form contains e", pi_exp.to_iter_bytes.check_any(|c| c == 'e'));;
    
    // Test negative numbers
    let neg = MPFR::mpfr(113, -3.14159);
    let neg_exp = neg.to_string_exp;
    assert(|_|"negative exp starts with -3.1", neg_exp.starts_with("-3.1"));;
    
    // Test very large number
    let large = MPFR::mpfr(113, 1.23e100);
    let large_exp = large.to_string_exp;
    assert(|_|"large number exp contains e+", large_exp.to_iter_bytes.check_any(|c| c == '+'));;
    
    // Test very small number
    let small = MPFR::mpfr(113, 1.23e-100);
    let small_exp = small.to_string_exp;
    assert(|_|"small number exp contains e-", small_exp.to_iter_bytes.check_any(|c| c == '-'));;
    
    // Test 1.0 (edge case)
    let one = MPFR::mpfr(113, 1.0);
    let one_exp = one.to_string_exp;
    assert(|_|"1.0 in exp format", one_exp == "1.0e+0");;
    
    // ==== to_string_exp_precision tests ====
    
    // Test basic case
    let x = MPFR::mpfr(113, 3.14159);
    let x_exp2 = x.to_string_exp_precision(2_U8);
    assert(|_|"3.14159 with exp precision 2", x_exp2 == "3.14e+0");;
    
    let y = MPFR::mpfr(113, 123.456);
    let y_exp3 = y.to_string_exp_precision(3_U8);
    assert(|_|"123.456 with exp precision 3", y_exp3 == "1.235e+2");;
    
    let z = MPFR::mpfr(113, 0.00123);
    let z_exp4 = z.to_string_exp_precision(4_U8);
    assert(|_|"0.00123 with exp precision 4 starts with 1.23", z_exp4.starts_with("1.23"));;
    
    // Test negative numbers
    let neg_x = MPFR::mpfr(113, -3.14159);
    let neg_x_exp2 = neg_x.to_string_exp_precision(2_U8);
    assert(|_|"negative with exp precision 2", neg_x_exp2 == "-3.14e+0");;
    
    // Test precision 0 (only integer part)
    let p0 = MPFR::mpfr(113, 5.6789);
    let p0_exp = p0.to_string_exp_precision(0_U8);
    assert(|_|"exp precision 0", p0_exp == "5.e+0" || p0_exp == "6.e+0");;  // May round
    
    // Test large exponent
    let large_e = MPFR::mpfr(113, 1.5e50);
    let large_e_str = large_e.to_string_exp_precision(2_U8);
    assert(|_|"large exp contains e+5", large_e_str.to_iter_bytes.check_any(|c| c == '+'));;
    
    // Test negative exponent
    let small_e = MPFR::mpfr(113, 1.5e-50);
    let small_e_str = small_e.to_string_exp_precision(2_U8);
    assert(|_|"small exp contains e-", small_e_str.to_iter_bytes.check_any(|c| c == '-'));;
    
    // ==== to_string_precision tests ====
    
    // Test basic case
    let a = MPFR::mpfr(113, 3.14159);
    let a_prec2 = a.to_string_precision(2_U8);
    assert(|_|"3.14159 with precision 2", a_prec2 == "3.14");;
    
    let b = MPFR::mpfr_i(113, 42);
    let b_prec3 = b.to_string_precision(3_U8);
    assert(|_|"42 with precision 3", b_prec3 == "42.000");;
    
    let c = MPFR::mpfr(113, 0.5);
    let c_prec5 = c.to_string_precision(5_U8);
    assert(|_|"0.5 with precision 5", c_prec5 == "0.50000");;
    
    // Test negative numbers
    let neg_a = MPFR::mpfr(113, -3.14159);
    let neg_a_prec2 = neg_a.to_string_precision(2_U8);
    assert(|_|"negative with precision 2", neg_a_prec2 == "-3.14");;
    
    // Test precision 0 (no decimal point)
    let prec0 = MPFR::mpfr(113, 3.7);
    let prec0_str = prec0.to_string_precision(0_U8);
    assert(|_|"precision 0", prec0_str == "3." || prec0_str == "4.");;  // May round
    
    // Test very small number with limited precision
    let tiny = MPFR::mpfr(113, 0.000123);
    let tiny_prec2 = tiny.to_string_precision(2_U8);
    assert(|_|"tiny number precision 2", tiny_prec2 == "0.00");;
    
    let tiny_prec5 = tiny.to_string_precision(5_U8);
    assert(|_|"tiny number precision 5", tiny_prec5.starts_with("0.00012"));;
    
    // Test large integer
    let big_int = MPFR::mpfr_i(113, 9999);
    let big_int_prec2 = big_int.to_string_precision(2_U8);
    assert(|_|"large int with precision 2", big_int_prec2 == "9999.00");;
    
    // Test number requiring padding
    let pad = MPFR::mpfr(113, 7.0);
    let pad_prec4 = pad.to_string_precision(4_U8);
    assert(|_|"7.0 with precision 4", pad_prec4 == "7.0000");;
    
    // Test decimal point in middle
    let mid = MPFR::mpfr(113, 12.34);
    let mid_prec3 = mid.to_string_precision(3_U8);
    assert(|_|"12.34 with precision 3", mid_prec3 == "12.339");;
    
    // ==== Special values tests ====
    
    let nan_val = MPFR::nan(53);
    assert(|_|"nan exp format", nan_val.to_string_exp == "@NaN@");;
    assert(|_|"nan exp precision format", nan_val.to_string_exp_precision(2_U8) == "@NaN@");;
    assert(|_|"nan precision format", nan_val.to_string_precision(2_U8) == "@NaN@");;
    
    let inf_val = MPFR::inf(53);
    assert(|_|"inf exp format", inf_val.to_string_exp == "@Inf@");;
    assert(|_|"inf exp precision format", inf_val.to_string_exp_precision(2_U8) == "@Inf@");;
    assert(|_|"inf precision format", inf_val.to_string_precision(2_U8) == "@Inf@");;
    
    let neg_inf_val = MPFR::neg_inf(53);
    assert(|_|"neg_inf exp format", neg_inf_val.to_string_exp == "-@Inf@");;
    assert(|_|"neg_inf exp precision format", neg_inf_val.to_string_exp_precision(2_U8) == "-@Inf@");;
    assert(|_|"neg_inf precision format", neg_inf_val.to_string_precision(2_U8) == "-@Inf@");;
    
    let zero = MPFR::zero(53);
    assert(|_|"zero exp format", zero.to_string_exp == "0.0e+0");;
    assert(|_|"zero exp precision 3", zero.to_string_exp_precision(3_U8) == "0.000e+0");;
    assert(|_|"zero precision 4", zero.to_string_precision(4_U8) == "0.0000");;
    
    pure()
);

// Comprehensive test for to_string edge cases
test_string_to_string_edge_cases : IO ();
test_string_to_string_edge_cases = (
    // ==== Negative numbers ====
    let neg1 = MPFR::mpfr(113, -42.0);
    assert(|_|"negative integer", neg1.to_string == "-42");;
    
    let neg2 = MPFR::mpfr(113, -0.5);
    assert(|_|"negative fraction", neg2.to_string.starts_with("-0.5"));;
    
    let neg3 = MPFR::mpfr(113, -0.001);
    assert(|_|"negative small", neg3.to_string.starts_with("-0.001"));;
    
    // ==== Powers of 10 ====
    let ten = MPFR::mpfr_i(113, 10);
    assert(|_|"10", ten.to_string == "10");;
    
    let hundred = MPFR::mpfr_i(113, 100);
    assert(|_|"100", hundred.to_string == "100");;
    
    let thousand = MPFR::mpfr_i(113, 1000);
    assert(|_|"1000", thousand.to_string == "1000");;
    
    // ==== Decimal fractions ====
    let tenth = MPFR::mpfr(113, 0.1);
    assert(|_|"0.1 starts correctly", tenth.to_string.starts_with("0.1"));;
    
    let hundredth = MPFR::mpfr(113, 0.01);
    assert(|_|"0.01 starts correctly", hundredth.to_string.starts_with("0.01"));;
    
    // ==== Numbers with trailing zeros (the original issue) ====
    let fifty = MPFR::mpfr_i(113, 50);
    assert(|_|"50 as integer", fifty.to_string == "50");;
    
    let five_point_zero = MPFR::mpfr(113, 5.0);
    assert(|_|"5.0", five_point_zero.to_string == "5");;
    
    // ==== Very large numbers (should use scientific notation) ====
    let huge = MPFR::mpfr(113, 1.23e100);
    let huge_str = huge.to_string;
    assert(|_|"huge number uses exp notation", huge_str.to_iter_bytes.check_any(|c| c == 'e'));;
    
    // ==== Very small numbers ====
    let tiny = MPFR::mpfr(113, 1.23e-50);
    let tiny_str = tiny.to_string;
    assert(|_|"tiny number format", tiny_str.starts_with("0.") || tiny_str.to_iter_bytes.check_any(|c| c == 'e'));;
    
    // ==== Numbers close to 1 ====
    let almost_one = MPFR::mpfr(113, 0.999999);
    assert(|_|"0.999999 starts correctly", almost_one.to_string.starts_with("0.999"));;
    
    let just_over_one = MPFR::mpfr(113, 1.000001);
    assert(|_|"1.000001 starts correctly", just_over_one.to_string.starts_with("1."));;
    
    // ==== Edge case: numbers where exp == len ====
    let exp_eq_len = MPFR::mpfr(113, 9.0);
    assert(|_|"9.0", exp_eq_len.to_string == "9");;
    
    // ==== Edge case: numbers where exp == len + 1 ====
    let exp_eq_len_plus = MPFR::mpfr(113, 99.0);
    assert(|_|"99.0", exp_eq_len_plus.to_string == "99");;
    
    // ==== Mixed: integer and fractional parts ====
    let mixed1 = MPFR::mpfr(113, 123.456);
    assert(|_|"123.456 has dot", mixed1.to_string.to_iter_bytes.check_any(|c| c == '.'));;
    assert(|_|"123.456 starts with 123", mixed1.to_string.starts_with("123"));;
    
    let mixed2 = MPFR::mpfr(113, 1.5);
    assert(|_|"1.5", mixed2.to_string.starts_with("1.5"));;
    
    // ==== Leading zeros after decimal point ====
    let leading_zeros1 = MPFR::mpfr(113, 0.0001);
    assert(|_|"0.0001 has leading zeros", leading_zeros1.to_string.starts_with("0.0001"));;
    
    let leading_zeros2 = MPFR::mpfr(113, 0.00000123);
    assert(|_|"0.00000123 has many leading zeros", leading_zeros2.to_string.starts_with("0.0"));;
    
    pure()
);

test_power_root : IO ();
test_power_root = (
    // Test sqr
    let x = MPFR::mpfr_i(113, 5);
    let x2 = x.sqr;
    assert_eq(|_|"sqr(5)", x2.get_si.as_some, 25);;

    // Test sqrt
    let y = MPFR::mpfr_i(113, 25);
    let y_sqrt = y.sqrt;
    assert_eq(|_|"sqrt(25)", y_sqrt.get_si.as_some, 5);;

    // Test cbrt
    let z = MPFR::mpfr_i(113, 27);
    let z_cbrt = z.cbrt;
    assert_eq(|_|"cbrt(27)", z_cbrt.get_si.as_some, 3);;

    // Test rootn_ui
    let w = MPFR::mpfr_i(113, 16);
    let w_root4 = MPFR::rootn_ui(4_U64, w);
    assert_eq(|_|"rootn_ui(4, 16)", w_root4.get_si.as_some, 2);;

    // Test pow
    let base = MPFR::mpfr_i(113, 2);
    let exp = MPFR::mpfr_i(113, 10);
    let result = MPFR::pow(base, exp);
    assert_eq(|_|"pow(2, 10)", result.get_si.as_some, 1024);;

    // Test pow_ui
    let base2 = MPFR::mpfr_i(113, 3);
    let result2 = MPFR::pow_ui(4_U64, base2);
    assert_eq(|_|"pow_ui(4, 3)", result2.get_si.as_some, 81);;

    // Test mul_2ui (multiply by 2^n)
    let a = MPFR::mpfr_i(113, 5);
    let a_shifted = MPFR::mul_2ui(3_U64, a);
    assert_eq(|_|"mul_2ui(3, 5)", a_shifted.get_si.as_some, 40);;

    pure()
);

test_exponential_logarithm : IO ();
test_exponential_logarithm = (
    // Test exp and log
    let x = MPFR::mpfr(113, 2.0);
    let exp_x = x.exp;
    let log_exp_x = exp_x.log;
    let diff = MPFR::abs(MPFR::sub(log_exp_x, x));
    assert(|_|"log(exp(x)) == x", diff.get_f64 < 0.000001);;

    // Test log2
    let eight = MPFR::mpfr_i(113, 8);
    let log2_8 = eight.log2;
    assert_eq(|_|"log2(8)", log2_8.get_si.as_some, 3);;

    // Test log10
    let thousand = MPFR::mpfr_i(113, 1000);
    let log10_1000 = thousand.log10;
    assert_eq(|_|"log10(1000)", log10_1000.get_si.as_some, 3);;

    pure()
);

test_trigonometric : IO ();
test_trigonometric = (
    let pi = MPFR::const_pi(113);
    
    // Test sin(pi/2) == 1
    let pi_2 = MPFR::div(pi, MPFR::mpfr_i(113, 2));
    let sin_pi_2 = pi_2.sin;
    let diff1 = MPFR::abs(MPFR::sub(sin_pi_2, MPFR::mpfr(113, 1.0)));
    assert(|_|"sin(pi/2) == 1", diff1.get_f64 < 0.000001);;

    // Test cos(0) == 1
    let zero = MPFR::mpfr_i(113, 0);
    let cos_0 = zero.cos;
    assert_eq(|_|"cos(0)", cos_0.get_si.as_some, 1);;

    // Test asin(1) ~= pi/2
    let one = MPFR::mpfr_i(113, 1);
    let asin_1 = one.asin;
    let diff2 = MPFR::abs(MPFR::sub(asin_1, pi_2));
    assert(|_|"asin(1) == pi/2", diff2.get_f64 < 0.000001);;

    // Test atan2
    let y = MPFR::mpfr_i(113, 1);
    let x = MPFR::mpfr_i(113, 1);
    let atan2_result = MPFR::atan2(y, x);
    let pi_4 = MPFR::div(pi, MPFR::mpfr_i(113, 4));
    let diff3 = MPFR::abs(MPFR::sub(atan2_result, pi_4));
    assert(|_|"atan2(1,1) == pi/4", diff3.get_f64 < 0.000001);;

    pure()
);

test_constants : IO ();
test_constants = (
    // Test const_pi
    let pi = MPFR::const_pi(113);
    let pi_f64 = pi.get_f64;
    assert(|_|"pi ~= 3.14159", (pi_f64 - 3.14159265358979).abs < 0.00001);;

    // Test const_log2
    let log2 = MPFR::const_log2(113);
    let log2_f64 = log2.get_f64;
    assert(|_|"log2 ~= 0.693", (log2_f64 - 0.69314718055995).abs < 0.00001);;

    // Test const_euler
    let euler = MPFR::const_euler(113);
    let euler_f64 = euler.get_f64;
    assert(|_|"euler ~= 0.577", (euler_f64 - 0.57721566490153).abs < 0.00001);;

    pure()
);

test_hyperbolic : IO ();
test_hyperbolic = (
    let zero = MPFR::mpfr_i(113, 0);
    
    // Test sinh(0) == 0
    let sinh_0 = zero.sinh;
    assert(|_|"sinh(0) == 0", sinh_0.is_zero);;

    // Test cosh(0) == 1
    let cosh_0 = zero.cosh;
    assert_eq(|_|"cosh(0)", cosh_0.get_si.as_some, 1);;

    // Test tanh identity: tanh(x) == sinh(x)/cosh(x)
    let x = MPFR::mpfr(113, 0.5);
    let tanh_x = x.tanh;
    let sinh_x = x.sinh;
    let cosh_x = x.cosh;
    let manual_tanh = MPFR::div(sinh_x, cosh_x);
    let diff = MPFR::abs(MPFR::sub(tanh_x, manual_tanh));
    assert(|_|"tanh(x) == sinh(x)/cosh(x)", diff.get_f64 < 0.000001);;

    // Test asinh(sinh(x)) ~= x
    let y = MPFR::mpfr(113, 1.0);
    let sinh_y = y.sinh;
    let asinh_sinh_y = sinh_y.asinh;
    let diff2 = MPFR::abs(MPFR::sub(asinh_sinh_y, y));
    assert(|_|"asinh(sinh(x)) == x", diff2.get_f64 < 0.000001);;

    pure()
);

test_special_functions : IO ();
test_special_functions = (
    // Test gamma(1) == 1
    let one = MPFR::mpfr_i(113, 1);
    let gamma_1 = one.gamma;
    assert_eq(|_|"gamma(1)", gamma_1.get_si.as_some, 1);;

    // Test gamma(5) == 24 (4!)
    let five = MPFR::mpfr_i(113, 5);
    let gamma_5 = five.gamma;
    assert_eq(|_|"gamma(5) == 24", gamma_5.get_si.as_some, 24);;

    // Test lngamma(1) == 0
    let lngamma_1 = one.lngamma;
    assert(|_|"lngamma(1) == 0", lngamma_1.is_zero);;

    // Test erf(0) == 0
    let zero = MPFR::mpfr_i(113, 0);
    let erf_0 = zero.erf;
    assert(|_|"erf(0) == 0", erf_0.is_zero);;

    // Test erfc(0) == 1
    let erfc_0 = zero.erfc;
    assert_eq(|_|"erfc(0) == 1", erfc_0.get_si.as_some, 1);;

    // Test erf(x) + erfc(x) == 1
    let x = MPFR::mpfr(113, 0.5);
    let erf_x = x.erf;
    let erfc_x = x.erfc;
    let sum = MPFR::add(erf_x, erfc_x);
    let diff = MPFR::abs(MPFR::sub(sum, MPFR::mpfr_i(113, 1)));
    assert(|_|"erf(x) + erfc(x) == 1", diff.get_f64 < 0.000001);;

    pure()
);

test_bit_shift_division : IO ();
test_bit_shift_division = (
    let x = MPFR::mpfr_i(113, 64);
    
    // Test div_2ui: 64 / 2^3 = 8
    let result = MPFR::div_2ui(3_U64, x);
    assert_eq(|_|"64 / 2^3", result.get_si.as_some, 8);;
    
    // Test div_2si: 64 / 2^2 = 16
    let result2 = MPFR::div_2si(2, x);
    assert_eq(|_|"64 / 2^2", result2.get_si.as_some, 16);;
    
    // Test div_2si with negative (multiply): 64 / 2^(-1) = 128
    let result3 = MPFR::div_2si(-1, x);
    assert_eq(|_|"64 / 2^(-1)", result3.get_si.as_some, 128);;
    
    pure()
);

test_exponential_extended : IO ();
test_exponential_extended = (
    // Test exp2: 2^3 = 8
    let x = MPFR::mpfr_i(113, 3);
    let result = x.exp2;
    assert_eq(|_|"2^3", result.get_si.as_some, 8);;
    
    // Test exp10: 10^2 = 100
    let y = MPFR::mpfr_i(113, 2);
    let result2 = y.exp10;
    assert_eq(|_|"10^2", result2.get_si.as_some, 100);;
    
    // Test expm1: expm1(0) = 0
    let zero = MPFR::mpfr_i(113, 0);
    let result3 = zero.expm1;
    assert(|_|"expm1(0)", result3.is_zero);;
    
    // Test log1p: log1p(0) = 0
    let result4 = zero.log1p;
    assert(|_|"log1p(0)", result4.is_zero);;
    
    pure()
);

test_integer_functions : IO ();
test_integer_functions = (
    let x = MPFR::mpfr(113, 3.7);
    
    // Test ceil: ceil(3.7) = 4
    let c = x.ceil;
    assert_eq(|_|"ceil(3.7)", c.get_si.as_some, 4);;
    
    // Test floor: floor(3.7) = 3
    let f = x.floor;
    assert_eq(|_|"floor(3.7)", f.get_si.as_some, 3);;
    
    // Test round: round(3.7) = 4
    let r = x.round;
    assert_eq(|_|"round(3.7)", r.get_si.as_some, 4);;
    
    // Test trunc: trunc(3.7) = 3
    let t = x.trunc;
    assert_eq(|_|"trunc(3.7)", t.get_si.as_some, 3);;
    
    // Test with negative number
    let y = MPFR::mpfr(113, -2.3);
    let c2 = y.ceil;
    assert_eq(|_|"ceil(-2.3)", c2.get_si.as_some, -2);;
    
    let f2 = y.floor;
    assert_eq(|_|"floor(-2.3)", f2.get_si.as_some, -3);;
    
    pure()
);

test_minmax : IO ();
test_minmax = (
    let x = MPFR::mpfr_i(113, 5);
    let y = MPFR::mpfr_i(113, 3);
    
    // Test min
    let min_val = MPFR::min(x, y);
    assert_eq(|_|"min(5, 3)", min_val.get_si.as_some, 3);;
    
    // Test max
    let max_val = MPFR::max(x, y);
    assert_eq(|_|"max(5, 3)", max_val.get_si.as_some, 5);;
    
    pure()
);

test_advanced_math : IO ();
test_advanced_math = (
    // Test fma: 2*3 + 4 = 10
    let x = MPFR::mpfr_i(113, 2);
    let y = MPFR::mpfr_i(113, 3);
    let z = MPFR::mpfr_i(113, 4);
    let result = MPFR::fma(x, y, z);
    assert_eq(|_|"2*3 + 4", result.get_si.as_some, 10);;
    
    // Test hypot: hypot(3, 4) = 5
    let a = MPFR::mpfr_i(113, 3);
    let b = MPFR::mpfr_i(113, 4);
    let h = MPFR::hypot(a, b);
    assert_eq(|_|"hypot(3, 4)", h.get_si.as_some, 5);;
    
    // Test fac_ui: 5! = 120
    let fac5 = MPFR::fac_ui(5_U64, 113);
    assert_eq(|_|"5!", fac5.get_si.as_some, 120);;
    
    // Test fmod: fmod(7, 3) = 1
    let p = MPFR::mpfr_i(113, 7);
    let q = MPFR::mpfr_i(113, 3);
    let fm = MPFR::fmod(p, q);
    assert_eq(|_|"fmod(7, 3)", fm.get_si.as_some, 1);;
    
    pure()
);

test_additional_trig : IO ();
test_additional_trig = (
    let zero = MPFR::mpfr_i(113, 0);
    
    // Test sec(0) = 1
    let sec_0 = zero.sec;
    assert_eq(|_|"sec(0)", sec_0.get_si.as_some, 1);;
    
    // Test sech(0) = 1
    let sech_0 = zero.sech;
    assert_eq(|_|"sech(0)", sech_0.get_si.as_some, 1);;
    
    pure()
);

test_zeta_beta : IO ();
test_zeta_beta = (
    // Test zeta_ui(2) ~= pi^2/6 ~= 1.6449
    let zeta_2 = MPFR::zeta_ui(2_U64, 113);
    let val = zeta_2.get_f64;
    assert(|_|"zeta(2) ~= 1.6449", (val - 1.6449).abs < 0.001);;
    
    // Test digamma(1) ~= -0.5772 (negative Euler constant)
    let one = MPFR::mpfr(113, 1.0);
    let dig1 = one.digamma;
    let val2 = dig1.get_f64;
    assert(|_|"digamma(1) ~= -0.5772", (val2 + 0.5772).abs < 0.001);;
    
    pure()
);

test_bessel : IO ();
test_bessel = (
    // Test j0(0) = 1
    let zero = MPFR::mpfr(113, 0.0);
    let j0_0 = zero.j0;
    assert_eq(|_|"j0(0)", j0_0.get_si.as_some, 1);;
    
    // Test j1(0) = 0
    let j1_0 = zero.j1;
    assert(|_|"j1(0)", j1_0.is_zero);;
    
    pure()
);

test_utilities : IO ();
test_utilities = (
    // Test signbit
    let pos = MPFR::mpfr(113, 5.0);
    let neg = MPFR::mpfr(113, -5.0);
    assert_eq(|_|"signbit(5)", pos.signbit, false);;
    assert_eq(|_|"signbit(-5)", neg.signbit, true);;
    
    // Test copysign: copysign(5, -3) = -5
    let x = MPFR::mpfr(113, 5.0);
    let y = MPFR::mpfr(113, -3.0);
    let result = MPFR::copysign(x, y);
    assert_eq(|_|"copysign(5, -3)", result.get_si.as_some, -5);;
    
    // Test const_catalan
    let catalan = MPFR::const_catalan(113);
    let val = catalan.get_f64;
    assert(|_|"Catalan constant ~= 0.9159", (val - 0.9159).abs < 0.001);;
    
    pure()
);

test : IO ();
test = (
    test_basic_construction;;
    test_arithmetic;;
    test_comparison;;
    test_conversion;;
    test_special_values;;
    test_precision;;
    test_string_conversion;;
    test_string_output;;
    test_string_formats;;
    test_string_to_string_edge_cases;;
    test_power_root;;
    test_exponential_logarithm;;
    test_trigonometric;;
    test_constants;;
    test_hyperbolic;;
    test_special_functions;;
    test_bit_shift_division;;
    test_exponential_extended;;
    test_integer_functions;;
    test_minmax;;
    test_advanced_math;;
    test_additional_trig;;
    test_zeta_beta;;
    test_bessel;;
    test_utilities;;

    pure()
);

main : IO ();
main = test;
